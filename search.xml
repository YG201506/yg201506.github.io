<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[资源失效留言]]></title>
    <url>%2F2019%2F11%2F08%2F%E5%A4%B1%E6%95%88%E7%95%99%E8%A8%80%2F</url>
    <content type="text"><![CDATA[百度云链接易被和谐，若公众号内有内容失效，请在下方留言，匿名与否均可，我看到了来更新，感谢支持~~]]></content>
      <categories>
        <category>资源</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++笔记]]></title>
    <url>%2F2019%2F10%2F20%2FC%2B%2B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[好记性不如烂笔头 //1////10层汉诺塔递归解法，过程输出到文件共移动 2的n次方减1次 #include #include using namespace std; ofstream fout(“out.txt”); void Move(int n, char i, char j){ fout &lt;&lt; “把” &lt;&lt; n &lt;&lt; “号从” &lt;&lt; i &lt;&lt; “移动到” &lt;&lt; j &lt;&lt; endl;} void Hannoi(int n, char a, char b, char c){ if (n == 1) { Move(1, a, c); } else { Hannoi(n - 1, a, c, b); Move(n, a, c); Hannoi(n - 1, b, a, c); }} int main(){ fout &lt;&lt; “以下是10层汉诺塔的解法:” &lt;&lt; endl; Hannoi(2, ‘a’, ‘b’, ‘c’); fout.close(); cout &lt;&lt; “输出结果完毕。” &lt;&lt; endl; system(“pauses”); return 0;} //2////容器 迭代器的使用 #include #include using namespace std; int main(){ vectorobj; for (int i = 0; i &lt; 10; i++) obj.push_back(i); //for (int i=0; obj.size(); i++) //尽量不要用下标的形式 // cout &lt;&lt; obj[i] &lt;&lt; “\t”; cout &lt;&lt; endl; //容器 //vector &lt;int&gt;::iterator p; //p = obj.begin(); //for (; p != obj.end();p++) // cout &lt;&lt; *p &lt;&lt; &quot;\t&quot;; //方法二，使用迭代器将容器中数据输出 vector&lt;int&gt;::iterator it;//声明一个迭代器，来访问vector容器，作用：遍历或者指向vector容器的元素 for (it = obj.begin(); it != obj.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; ...&quot;; } system(&quot;pause&quot;); } //3//c++双向队列的使用2019年04月10日 14:58:39 reaching_dream 阅读数 155更多分类专栏： 编程 C++版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。本文链接：https://blog.csdn.net/weixin_42056625/article/details/89181657首先我们先简单说明c++的双向队列c++的双向队列比队列具有更加灵活的特性，可以对队列中两端的元素进行操作。包含文件为 #include声明为： deque d; type为声明的变量类型，其中d为声明的变量名常见的操作有以下几种方式：push_back: 从尾部添加元素push_front: 从头部添加元素pop_back: 从尾部删除元素pop_front: 从头部删除元素insert: 插入一个元素erase 删除一个元素更加具体的函数可以参考c++的官方网站对于deque的说明：http://www.cplusplus.com/reference/deque/deque/?kw=deque 下面我们来看一下这里例子，这里具体的说明如何使用上面的函数，程序里具体说明了每一步的解释： #include #includeusing namespace std; int main(){ deque d; //从尾部插入0到4 for (int i = 0; i &lt; 5; i++) { d.push_back(i); cout &lt;&lt; i &lt;&lt; “ “; } //从头部插入20到16 for (int i = 20; i&gt;15; i–) { d.push_front(i); cout &lt;&lt; i &lt;&lt; “ “; } cout &lt;&lt; endl; //现在双向队列中按从头到位的顺序为16 17 18 19 20 0 1 2 3 4 //输出双向队列中的所有元素 cout &lt;&lt; “按照一头一尾的方式输出双向队列中的所有元素” &lt;&lt; endl; //正确的输出结果应该是16 4 17 3 18 2 19 1 20 0 while (!d.empty()) { cout &lt;&lt; d.front() &lt;&lt; “ “; d.pop_front(); cout &lt;&lt; d.back() &lt;&lt; “ “; d.pop_back(); } cout&lt;&lt;endl; deque::iterator it = d.begin(); //删除了所有元素以后我们重新对双向队列赋值 for (int i = 0; i &lt; 10; i++) { d.push_back(i); } //输出现在队列中的元素 for (it = d.begin(); it != d.end(); it++) { cout &lt;&lt;*it &lt;&lt; “ “; } cout &lt;&lt; endl; //接下来我们演示在第3个元素中插入5个10,然后删除倒数第2个元素 it = d.begin();//让it指向第三个元素 d.insert(it+2,5,10);//这里的5代表插入的元素个数 it = d.end(); d.erase(it - 2);//删除倒数第二个元素 //查看现在双向队列中的元素 for (it = d.begin(); it != d.end(); it++) { cout &lt;&lt;*it &lt;&lt; &quot; &quot;; } system(&quot;pause&quot;); return 0; }下面是对应的输出截图： //4////8进制 #include using namespace std; int main(){ int oo=0655; cout &lt;&lt; oo &lt;&lt; “\t”; //429 system(&quot;pause&quot;); } //5////小数格式 #include #include using namespace std; int main(){ cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setiosflags(ios::right); cout &lt;&lt; setw(10) &lt;&lt; 34.3434 &lt;&lt; endl; cout &lt;&lt; setw(10) &lt;&lt; 4.8989888 &lt;&lt; endl; cout &lt;&lt; setw(10) &lt;&lt; 0.5454 &lt;&lt; endl; cout &lt;&lt; setw(10) &lt;&lt; 232.7878 &lt;&lt; endl; system(“pause”);} //6////if使用 #include #include using namespace std; //分段函数//x&gt;200 y=89;//x&gt;100 y=88;//other y=87;int main(){ int n=340;//给定默认 if (n &gt; 200)cout &lt;&lt; 89 &lt;&lt; endl; else if(n&gt;100)cout &lt;&lt; 88 &lt;&lt; endl; else cout &lt;&lt; 87 &lt;&lt; endl; system(“pause”);} //7////求π #include #include using namespace std; int main(){ double sum = 0.0, t = 1.0, n = 1.0; int s = 1; for (; fabs(t) &gt; 1e-7; ) { //cout &lt;&lt; n &lt;&lt; endl; t = s / n; sum = sum + t; s = -s; n += 2;//不能放到for的第三个条件 } cout &lt;&lt; sum * 4; system(&quot;pause&quot;); } //8////斐波那契数列 #include #include using namespace std; int main(){ int a[100]; a[0] = 1, a[1] = 1; int x = a[0] + a[1]; cout &lt;&lt; a[1] &lt;&lt; endl; for (int i = 2; i &lt; 20; i++) { a[i] = a[i - 1] + a[i - 2]; cout &lt;&lt; a[i] &lt;&lt; endl; } system(&quot;pause&quot;); } //10////100-200间的素数 #include #include using namespace std; int main(){ int num = 0; for (size_t i = 101; i &lt; 200; i+=2) { int flag = 1; for (size_t j = 2; j &lt;= sqrt(i); j++) { if (i%j == 0) { flag = 0; break; } } if (flag == 1) cout &lt;&lt; i &lt;&lt; “\t” &lt;&lt; ++num &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } //11////1000 0000 0内的完数 #include #include using namespace std; int main(){ int num = 0; for (size_t i = 2; i &lt; 10000; i+=2)//太大了算不出来 { int flag = 1, sum = 0; for (size_t j = 1; j &lt; i; j++) { if (i%j == 0) { sum += j; //cout &lt;&lt; sum &lt;&lt; “\t”; } } ///cout &lt;&lt; endl; if (sum==i) cout &lt;&lt; i &lt;&lt; “\t” &lt;&lt; ++num &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } //12////4个数中最大 #include #include using namespace std; int main(){ int num = 0; int a = 9, b = 19, c = 1, d = 88; if (a&lt;b) a = b; if (c&gt;d) d = c; if (a&lt;d) a = d; cout &lt;&lt; “max = “ &lt;&lt; a &lt;&lt; endl; system(“pause”); return 0;} //12////两队都有3人 a不与x,c不与下x,z 问对手 #include #include using namespace std; int main(){ char x, y, z; for (x = ‘x’; x &lt;= ‘z’; x++) for (y = ‘x’; y &lt;= ‘z’; y++) if (x != y) for (z = ‘x’; z &lt; ‘z’; z++) if (x!=z&amp;&amp;y != z) if (x != ‘x’&amp;&amp;z != ‘x’&amp;&amp;z != ‘z’) { cout &lt;&lt; “a–&gt;” &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; “b–&gt;” &lt;&lt; y &lt;&lt; endl; cout &lt;&lt; “c–&gt;” &lt;&lt; z &lt;&lt; endl; } system(“pause”); return 0;} //13////两个特殊的重载函数 #include #include using namespace std;class MyClass{public: void overload() //只能写在类里 { cout &lt;&lt; “测试1” &lt;&lt; endl; } void overload()const { cout &lt;&lt; &quot;测试2&quot; &lt;&lt; endl; } private: }; int main(){ MyClass obj1; obj1.overload();//默认调用不加const的函数 /obj.overload()const;///错误 不能这样调用 MyClass const obj2; obj2.overload(); system(&quot;pause&quot;); return 0; } //14////函数模板 #include #include using namespace std; template void f(T a,T b){ T c = a - b; cout &lt;&lt; c &lt;&lt; endl;} int main(){ f(34, 444); f(‘g’,’a’); system(“pause”); return 0;} //15////类模板 及在类外定义模板函数 #include #include using namespace std; template class MyClass{public: MyClass(T aa, T bb) { a = aa; b = bb; } T a; T b; void f1() { cout &lt;&lt; a &lt;&lt; endl &lt;&lt; b &lt;&lt; endl; } T f2();private: }; template T MyClass :: f2(){ T c; c = a + b; cout &lt;&lt; c; return c;}int main(){ MyClass obj(44, 43434); obj.f1(); obj.f2(); system(“pause”); return 0;} //17////不加头文件使用系统函数 #include int main(){ double sin(double x); std::cout &lt;&lt; sin(3.14); system(“pause”); return 0;} //18////数字转字符串 #include using namespace std; int f(int a){ char c; if (a &lt; 10) { cout &lt;&lt; a; return a; } else f(a / 10); c = (a % 10)+48; //原来的数字对应实际的ASCII ，如个位数为4，ASCII为4，在此基础上增加48转为对应的ASCII的数字 cout &lt;&lt; c; }int main(){ int a; a = 1234; cout &lt;&lt; a &lt;&lt; &quot;表示成字符串为：&quot;; f(a); system(&quot;pause&quot;); return 0; } //20////调用函数 求i的阶乘 #include using namespace std; int f(int a){ int res= a; if (a == 1) return a; else { res *= f(a-1); return res; }}int main(){ int a = 5; cout &lt;&lt; f(a) &lt;&lt; ‘\t’; system(“pause”); return 0;} //21////调用函数 求i^2 求和 #include using namespace std; int f(int a) //函数内if和else都要有返回值{ int res= a; if (a == 1) return a; else { res *= res; res += f(a-1); return res; }}int main(){ int a = 4; cout &lt;&lt; f(a) &lt;&lt; ‘\t’; system(“pause”); return 0;} //23////最大公约数 最小公倍数 #include using namespace std; int f1(int a,int b)//最大公约数{ int temp; if (a &lt; b) { temp = a; a = b; b = temp; } if ((a % b) == 0) { return b; } else { return f1(b, a - b); }} int f2(int a,int b)//最小公倍数{ int res; res = a*b / f1(a, b); //原数的乘积除以最大公约数 return res;} int main(){ int a = 40; int b = 20015; cout &lt;&lt; f1(a, b) &lt;&lt; ‘\t’; cout &lt;&lt; f2(a,b) ; system(“pause”); return 0;} //24////cin.getline 单独无法使用 #include #include using namespace std; int main(){ char a[34] = {“dfdf”}; cin.getline(a,33); cout &lt;&lt; a; system(“pause”); return 0;} //25////二维数组指针 #include #include #pragma warning (disable :4996)using namespace std; int main(){ //方式1 int a[2][3] = { 23,34 }; int p; p = a[0]; cout &lt;&lt; p[0] &lt;&lt; endl;//23 cout &lt;&lt; p &lt;&lt; endl;//23 //方式2 int *p1[3] = { a[0] ,a[1]}; cout &lt;&lt;p[0];//23 //方式3 int(*pp)[3] = a; cout &lt;&lt; p[0];//23 cout &lt;&lt; (*pp)[0];//23 //cout &lt;&lt; p[0][1];//23 //error system(&quot;pause&quot;); return 0; } //26////const指针 #include #include #pragma warning (disable :4996)using namespace std; int main(){ //No1 指向变量的指针变量 int a = 23; const int pa = &a;//不能通过指针修改原来指向的变量的值 //p = 34; //error 错误信息 ：必须是可赋值的左值 //No2 常指针 int b = 23; int bb = 34; int * const pb = &amp;a;//不能修改指针指向 //pb = &amp;bb; //error 错误信息 ：必须是可赋值的左值 //No3 //以上两种的综合 system(&quot;pause&quot;); return 0; } //27////指向对象成员函数的指针 #include “myiostream.h” #pragma warning (disable :4996)using namespace std; class MyClass{public: void f();private: }; void MyClass ::f(){ cout &lt;&lt; “lalala”;} int main(){ //1 void (MyClass :: *p2)(); //指向对象成员函数的指针 的定义 //p2 = &amp;MyClass::f(); //error p2 = &amp;MyClass::f; //注:无括号 //2 //直接写是指向对象的指针: MyClass *pp; system(&quot;pause&quot;); return 0; } //28////对象的动态建立与初始化 #include “myiostream.h” #pragma warning (disable :4996)using namespace std; class MyClass{public: MyClass(){} MyClass(int aa) { a = aa; } void f();private: int a;}; void MyClass ::f(){ cout &lt;&lt; “lalala” &lt;&lt; a;}int main(){ MyClass *pp; pp = new MyClass; MyClass *pp2; pp2 = new MyClass(666); pp2-&gt;f(); system(&quot;pause&quot;); return 0; } //29////普通函数作为友元 #include “myiostream.h” #pragma warning (disable :4996)using namespace std; class MyClass{public: MyClass(){} MyClass(int aa) { a = aa; } void f(); friend void myfriend(MyClass &amp; obj);private: int a;}; void MyClass ::f(){ cout &lt;&lt; “lalala” &lt;&lt; a;} void myfriend(MyClass &amp; obj){ cout &lt;&lt; “开心” &lt;&lt; obj.a;} int main(){ MyClass *pp; pp = new MyClass; MyClass *pp2; pp2 = new MyClass(666); pp2-&gt;f(); MyClass obj(888); myfriend(obj); system(&quot;pause&quot;); return 0; } //30////原来的字符个数，加上%d代表的个数 #include&lt;stdio.h&gt; int main(){ int x=77797; x=printf(&quot;tt%d&quot;,x);//x是输出的字符的个数 //原来的字符个数，加上%d代表的个数 printf(&quot;%d&quot;,x); } //31////静态成员函数使用//一般来说//静态成员函数用来调用静态成员（非绝对）//非静态成员函数来调用非静态成员（非绝对） #include “myiostream.h” #pragma warning (disable :4996)using namespace std; class MyClass{public: MyClass(){} MyClass(int aa) :a(aa) {} void static f(); static int sum; static int count;private: int a; }; void MyClass ::f(){ cout &lt;&lt; sum/count ;} int MyClass::sum = 50;int MyClass::count = 50; int main(){ cout &lt;&lt; MyClass::sum; MyClass::f(); system(“pause”); return 0;} //32////“+-*/“ 成员函数重载 实现复数运算 #include “myiostream.h” #pragma warning (disable :4996)using namespace std; class MyClass{public: MyClass(){} MyClass(double real,double image) :a(real),b(image) {} MyClass operator+(MyClass &amp;c2); MyClass MyClass::operator-(MyClass &amp;c2); MyClass MyClass::operator*(MyClass &amp;c2); MyClass MyClass::operator/(MyClass &amp;c2); void disp() { if (b &gt; 0) { cout &lt;&lt; “(“ &lt;&lt; a &lt;&lt; “+” &lt;&lt; b &lt;&lt; “i)” &lt;&lt; endl; } else { cout &lt;&lt; “(“ &lt;&lt; a &lt;&lt; “” &lt;&lt; b &lt;&lt; “i)” &lt;&lt; endl; } }private: double a; double b;}; MyClass MyClass::operator+(MyClass &amp;c2){ MyClass temp; temp.a = a + c2.a; temp.b = b + c2.b; return temp;} MyClass MyClass::operator-(MyClass &amp;c2){ MyClass temp; temp.a = a - c2.a; temp.b = b - c2.b; return temp;} MyClass MyClass::operator(MyClass &amp;c2){ MyClass temp; temp.a = a c2.a - b c2.b; temp.b = b c2.a + a * c2.b; return temp;} MyClass MyClass::operator/(MyClass &amp;c2){ MyClass temp; double c; c = c2.ac2.a + c2.bc2.b; temp.a = a c2.a + b c2.b; temp.a = temp.a / c; temp.b = b * c2.a - a * c2.b; temp.b = temp.b / c; return temp; } int main(){ MyClass obj1(23, 44), obj2(111, 222), obj3; obj3 = obj1 + obj2; obj3 = obj1 - obj2; obj3 = obj1 / obj2; obj3.disp(); system(“pause”); return 0;} //显示调用成员函数重载符//int main()//{// MyClass obj1(1, 1), obj2(2, 2), obj3;// obj3 = obj2.operator+(obj1);// obj3.disp();// system(“pause”);// return 0;//} //33////“+-*/“ 友元重载 实现复数运算 #include “myiostream.h” #pragma warning (disable :4996)using namespace std; class MyClass{public: MyClass(){} MyClass(double real,double image) :a(real),b(image) {} friend MyClass operator+(MyClass &amp;, MyClass &amp;); friend MyClass operator-(MyClass &amp;, MyClass &amp;); friend MyClass operator*(MyClass &amp;, MyClass &amp;); friend MyClass operator/(MyClass &amp;, MyClass &amp;); void disp() { if (b &gt; 0) { cout &lt;&lt; &quot;(&quot; &lt;&lt; a &lt;&lt; &quot;+&quot; &lt;&lt; b &lt;&lt; &quot;i)&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;(&quot; &lt;&lt; a &lt;&lt; &quot;&quot; &lt;&lt; b &lt;&lt; &quot;i)&quot; &lt;&lt; endl; } } private: double a; double b;}; MyClass operator+(MyClass &amp;c1, MyClass &amp;c2){ MyClass temp; temp.a = c1.a + c2.a; temp.b = c1.b + c2.b; return temp;} MyClass operator-(MyClass &amp;c1, MyClass &amp;c2){ MyClass temp; temp.a = c1.a - c2.a; temp.b = c1.b - c2.b; return temp;} MyClass operator(MyClass &amp;c1, MyClass &amp;c2){ MyClass temp; temp.a = c1.a c2.a - c1.b c2.b; temp.b = c1.b c2.a + c1.a * c2.b; return temp;} MyClass operator/(MyClass &amp;c1, MyClass &amp;c2){ MyClass temp; double c; c = c2.ac2.a + c2.bc2.b; temp.a = c1.a c2.a + c1.b c2.b; temp.a = temp.a / c; temp.b = c1.b c2.a - c1.a c2.b; temp.b = temp.b / c; return temp;} int main(){ MyClass obj1(23, 44), obj2(111, 222), obj3; obj3 = obj1 + obj2; obj3 = obj1 - obj2; obj3 = obj1 / obj2; obj3 = obj1 * obj2; obj3.disp(); system(“pause”); return 0;} //32////“== &gt;” 友元重载 实现复数运算 #include “myiostream.h” #pragma warning (disable :4996)using namespace std; class MyClass{public: MyClass(){} MyClass(string str11) :str1(str11){} friend bool operator==(MyClass &amp;, MyClass &amp;); friend int operator&gt;(MyClass &amp;, MyClass &amp;); void disp() { cout &lt;&lt; &quot;string:&quot; &lt;&lt; str1 &lt;&lt; endl; } private: string str1;}; bool operator==(MyClass &amp;obj1, MyClass &amp;obj2){ if(obj1.str1 == obj2.str1) return 1; else return 0;} int operator&gt;(MyClass &amp;obj1, MyClass &amp;obj2){ if (obj1.str1 &gt; obj2.str1) return 1; else if (obj1.str1 &lt; obj2.str1) return 2; else return 0;} int main(){ MyClass obj1(“good”), obj2(“well”), obj3; int flag = obj1 &gt; obj2; obj1.disp(); obj2.disp(); cout &lt;&lt; “第” &lt;&lt; flag &lt;&lt; “大” &lt;&lt; endl; system(&quot;pause&quot;); return 0; } //33////“++” 成员函数重载 实现自加（前置 后置） #include “myiostream.h” #pragma warning (disable :4996)using namespace std; class MyClass{public: MyClass() {} MyClass(double x) :a(x){} MyClass operator++(); MyClass operator++(int); double a;private: }; MyClass MyClass::operator++(){ ++a; return *this;} MyClass MyClass::operator++(int){ a++; return *this;} int main(){ MyClass obj1(665); ++obj1; cout &lt;&lt; obj1.a; //666 obj1++; cout &lt;&lt; obj1.a; //667 system(“pause”); return 0;} 注意问题：重载符必须和原来的操作对象个数相同，双目重载时还是双目，单目重载时是单目 //32////选择法排序（10个数） #include “myiostream.h” #pragma warning (disable :4996)using namespace std; void f(int *a)//{ int min, t; size_t j; size_t i; for (i = 0; i &lt; 10-1; i++) { min = i; for (j = i+1; j &lt; 10; j++) { if (a[min] &gt; a[j]) min = j; } swap(a[min], a[i]); } for (size_t i = 0; i &lt; 10; i++) { cout &lt;&lt; a[i] &lt;&lt; &quot;\t&quot;; } } void swap(int&amp;a, int &amp;b){ int t=0; //需要赋初值 a = t; t = b; b = t;} int main(){ int a[10] = { 23,45,56,35,34,65,57,23,1,7 }; f(a); system(“pause”); return 0;} //33////鞍点 #include “myiostream.h” #pragma warning (disable :4996)using namespace std; void f(int (*a)[3])//{ int flag = 1; for (size_t i = 0; i &lt; 3; i++) { int max = a[i][0], maxj = 0; //假设行最大值为max 最大值的下标为maxj for (size_t j = 0; j &lt; 3; j++) { if (max &lt; a[i][j]) { max = a[i][j]; maxj = j; } } flag = 1; //假设每一行的最大值都有可能是鞍点 for (int k = 0; k &lt; 3; k++) { if (max &gt; a[k][maxj]) { flag = 0; continue;//次句可不要 增加只是减少运算次数，意为只要出现小于max的数停止本次计算 } } if (flag) { cout &lt;&lt; “鞍点坐标为：” &lt;&lt; i + 1 &lt;&lt; “,” &lt;&lt; maxj + 1; cout &lt;&lt; “ 其数值为：” &lt;&lt; max; } }} int main(){ int a[3][3] = { 1,2,3,1,2,4,2,2,5}; f(a); system(“pause”); return 0;} //34////折半查找(二分法) 一串数已经有序 则查找item在一串数中的位置比较次数为logn+1 #include “myiostream.h” #pragma warning (disable :4996)using namespace std; //非递归void f1(int *a,int low,int high,int key)//a[]数组 key为要查找的数{ int mid; while (low&lt;=high) { mid = (low + high) / 2; if (a[mid] == key) { cout &lt;&lt; key &lt;&lt; “下标为（从1开始）：” &lt;&lt; mid + 1 &lt;&lt; endl; break; } else if (a[mid] &lt; key) { low = mid + 1; } else high = mid - 1; }} //递归int f2(int *a, int low, int high, int key)//a[]数组 key为要查找的数{ int mid; if (low &gt; high) return -1; else { mid = (low + high) / 2; if (a[mid] == key) { cout &lt;&lt; key &lt;&lt; “下标为（从1开始）：” &lt;&lt; mid + 1 &lt;&lt; endl; return 1; } else if (a[mid] &lt; key) { f2(a, mid + 1, high, 8); } else f2(a, low, mid - 1, 8); }} int main(){ int a[10]= { 1,2,3,4,5,6,7,8,9,10}; f1(a,0,9,8); //方法1 f2(a, 0, 9, 8);// //方法2 system(“pause”); return 0;} //35////指针运用：后移部分数据//如后移1,4//移动前：1 4 4 7 8 4//移动后：4 7 8 4 1 4 #include “myiostream.h” #pragma warning (disable :4996)using namespace std; void f(int a,int n,int m)//a[]数组 n为数据总数 m为后移个数{ int p; int a_end; a_end = (a+n-1); //步骤1：前移后面n-1个元素 for (p = a + n - 1; p &gt; a; p–) { p = (p - 1); } //步骤2：开始时的第一个元素放最后 a = a_end; //步骤3：一共移动m次 m–; if (m &gt; 0)f(a, n, m);} int main(){ int a[10]= { 1,2,3,4,5,6,7,8,9,10}; f(a,10,3); for (size_t i = 0; i &lt; 10; i++) { cout &lt;&lt; a[i] &lt;&lt; “\t”; } system(“pause”); return 0;} //36////指针运用：约瑟夫 （报数问题）//从第k个人报数，凡报到3的人退出。问最后剩余的那一人的编号 #include “myiostream.h” #pragma warning (disable :4996)using namespace std; void f(int a,int n)// a[]为一圈人的编号 n总人数 k为开始报数的编号 m为每次报到出圈的人3{ int i, m, k; m = 0; i = 0; k = 0;//初始化 int p = a; while (m &lt; n - 1)//m累加是出圈总人数(在数组中重置为0即出圈) { if ((p + i) != 0) { k++; } if (k == 3) { (p + i) = 0; k = 0; m++; } i++; if (i == n)i = 0; //次句相当于循环，即到末尾时重置 } while (p == 0) { p++; } cout &lt;&lt; p; } int main(){ int a[8]= { 1,2,3,4,5,6,7,8};//给每个人编号(从1开始)，假设共10个人 f(a,8); system(“pause”); return 0;} //37////字典排序 https://blog.csdn.net/qq_34672688/article/details/79557380//总结得出字典排序算法四步法：////字典排序：//第一步：从右至左找第一个左邻小于右邻的数，记下位置i，值list[a]//第二部：从右边往左找第一个右边大于list[a]的第一个值，记下位置j，值list[b]//第三步：交换list[a]和list[b]的值//第四步：将i以后的元素重新按从小到大的顺序排列//////举例：125643的下一个字典序列//第一步：右边值大于左边的3&lt;4, 4&lt;6, 6&gt;5, 则i = 2（从0开始），list[a] = 5// 第二步：从右往左找出第一个右边大于list[a] = 5的值，找到6&gt;5, j = 3; list[b] = 6;//第三步：交换list[a]和list[b]的值，序列125643-&gt;126543//第四步：将位置2以后的元素重新排序, 126543-&gt;126345;//结束： 126345即125643的下一个序列 #include “myiostream.h” #pragma warning (disable :4996)using namespace std;//注意宏函数不能不能写为swap(int a,int b)//注意宏函数{}不能换行 #define swap(a,b) {int t;t = a;a = b;b = t;} //冒泡排序对数组中的一段数据进行排序void sort(int *a, int start, int end)//形参：数组 开始位置（从0开始） 结束位置{ for (size_t i = 0; i &lt;= end - start; i++) { for (size_t j = start; j &lt; end - i; j++) { if (a[j] &gt; a[j+1]) swap(a[j], a[j+1]); } }} void 字典排序(int a, int n){ int 阶乘=1; int xx, jj;//记录要交换的位置 size_t j; size_t i; size_t k; for (i = 1; i &lt;= n; i++) { 阶乘 = i; } sort(a,0,n-1); for (i = 0; i &lt; 阶乘; i++) { for (j = 0; j &lt; n; j++) { cout &lt;&lt; a[j]; } cout &lt;&lt; endl; for (k = n - 1; k &gt; 0; k–)//字典步骤1 (不能写成k &gt;= 0) { if (a[k - 1] &lt; a[k]) { xx = k-1;//不能写成xx=k break; } } for (k = n - 1; k &gt;= 0; k–)//字典步骤2 { if (a[k] &gt; a[xx]) { jj = k; break; } } swap(a[xx], a[jj]);//字典步骤3 //注意是xx后的元素进行排序 xx+1 sort(a, xx+1, n - 1);////字典步骤4 }} int main(){ int a[4]= {1,2,3,4};//给每个人编号(从1开始)，假设共10个人 字典排序(a,4); system(“pause”); return 0;} //38////3个等长字符串排序输出 #include #include using namespace std; //冒泡 string方式void sort(string a[3]){ for (size_t j = 0; j &lt; 3-1; j++) { for (size_t i = 0; i &lt; 3-j-1; i++) { string temp; if (a[i] &gt; a[i + 1]) { temp = a[i]; a[i] = a[i + 1]; a[i + 1] = temp; } } } } int main(){ string a[3] = { “zrer”,”mfgs”,”pppp” }; sort(a); for (size_t i = 0; i &lt; 3; i++) { cout &lt;&lt; a[i] &lt;&lt; “\t”; } system(“pause”); return 0;} //40////计算积分 一元积分 二重积分 #include #include #include using namespace std; //被积函数double f(double x){ return pow(2.71,x);} //被积函数(重载，计算二重积分)double f(double x, double y){ return x*y;} //一元积分 微元：矩形 = 长宽//积分=Sigma(a+(b-a)/ni)b-a)/nvoid f1(double a, double b, int n) //积分下限 积分上限 分割份数{ //累加法求面积(定积分定的精确定义) double s = 0.0; double t = (b - a) / n; for (size_t i = 0; i &lt; n; i++) { s += f(a + it)t; } cout &lt;&lt; s &lt;&lt; endl;} //二重积分 SigmaSigma(a+(b-a)/n i (b-a)/n,c+(d-c)/ni))d-c)/nvoid f2(double a, double b, double c, double d, int n)//x,y的下限 上限{//精度较高 时计算速度较慢 //累加法求面积(定积分定的精确定义) double s = 0.0; double t1 = (b - a) / n; double t2 = (d - c) / n; for (size_t i = 0; i &lt; n; i++) { for (size_t j = 0; j &lt; n; j++) { s += f(a + it1, c + jt2)t1*t2; } } cout &lt;&lt; s &lt;&lt; endl;} int main(){ f1(0, 2, 100000); f2(0, 1, 0, 1, 1000); system(“pause”); return 0;} //41////输入一串字符 输出字符中的数字及个数 如sd 123hfj555sdf333sfhj 输出123 555 333 3个 #include #include #include using namespace std; void convert(char a,int n)//字符转数字,形参为字符串及长度{ int sum=0; for (size_t i = 0; i &lt; n; i++) { sum += (a[i]-48) pow(10, n - 1 - i); } cout &lt;&lt; sum &lt;&lt; endl;}void f(char a){ char p, r; int i=0;//统计每次找到的数字的位数 for (p = a; p != ‘\0’; p++) { if ((p &gt;= ‘0’)&amp;&amp;(p &lt;= ‘9’)) { i++; } else if( (p != ‘0’) &amp;&amp; (p != ‘9’)) { if (i &gt; 0) { r = p - i; convert(r, i); i = 0; } } if (*(p+1) == ‘\0’) //不能写为else if 这是一个特殊情况 { if (i &gt; 0) { r = p - i + 1; //此处和上边有细微差别 convert(r, i); i = 0; } } }} int main(){ char a[] = { “ddfn2334nfgjn78” }; f(a); system(“pause”); return 0;} //42////ABCDEFG7位医生 每人每周值班一次 要求：/（1）A比C晚一天（2）D比E晚两天（3）G比B晚3天（4）F在B与C之间，F在周四 / #include #include using namespace std; enum MyEnum{ sun=1, mon, tus, wed, thu, fri, sat //此处结尾无分号}; //根据每位医生的限制条件void f(){ int f = thu;//F医生 for (size_t a = sun; a &lt;= sat; a++) if (a != f) for (int b = sun; b &lt;= sat; b++) if (b != a&amp;&amp;f &gt; b) for (int c = sun; c &lt;= sat; c++) if (c != a&amp;&amp;c &gt; f&amp;&amp;c + 1 == a&amp;&amp;c!=b) for (int d = sun; d &lt;= sat; d++) if (d != a&amp;&amp;d!=b&amp;&amp;d!=c&amp;&amp;a!=f) for (int e = sun; e &lt;= sat; e++) if (e != a&amp;&amp;e!=b&amp;&amp;e!=c&amp;&amp;d == e + 2&amp;&amp;e!=f) for (int g = sun; g &lt;= sat; g++) if(g!=a&amp;&amp;g==b+3&amp;&amp;g!=c&amp;&amp;g!=d&amp;&amp;g!=e&amp;&amp;g!=f) cout &lt;&lt; a &lt;&lt; “,” &lt;&lt; b &lt;&lt; “,” &lt;&lt; c &lt;&lt; “,” &lt;&lt; d &lt;&lt; “,” &lt;&lt; e &lt;&lt; “,” &lt;&lt; f &lt;&lt; “,” &lt;&lt; g &lt;&lt; endl; } int main(){ f(); system(“pause”); return 0;} //43////重载流提取和流输入 &lt;&lt; &gt;&gt; #include #include using namespace std; class MyClass{public: MyClass(int aa):a(aa){} friend istream &amp;operator&gt;&gt;(istream&amp;, MyClass&amp;); friend ostream &amp;operator&lt;&lt;(ostream&amp;, MyClass&amp;); private: int a;}; istream &amp;operator &gt;&gt;(istream&amp;mycin, MyClass&amp;obj1){ mycin &gt;&gt; obj1.a; return mycin;}ostream &amp;operator&lt;&lt;(ostream&amp;mycout, MyClass&amp;obj2){ mycout &lt;&lt; “这是一个对象输出:” &lt;&lt; obj2.a &lt;&lt; endl; return mycout;}int main(){ MyClass obj(666); cin &gt;&gt; obj; cout &lt;&lt; obj; system(“pause”); return 0;} //43////转换构造函数 #include using namespace std; class MyClass{public: MyClass(){} MyClass(int a) { real = a; imag = 0; }//转换构造 只有一个形参 MyClass(int a,int b) { real = a; imag = b; } MyClass operator+(MyClass&amp;obj) { real += obj.real; imag += obj.imag; return *this; } void dis() { cout &lt;&lt; real &lt;&lt; “,” &lt;&lt; imag; }private: int real, imag;}; int main(){ MyClass obj1(3),obj2; obj2 = obj1 + MyClass(3.5); //注意转换函数的使用是：类名（参数） obj2.dis(); system(“pause”); return 0;} //44////类型转换函数 #include using namespace std; class MyClass{public: MyClass(){} MyClass(int a) { real = a; imag = 0; }//转换构造 只有一个形参 MyClass(int a,int b) { real = a; imag = b; } operator int()//没有参数 返回类型为int 只能做为成员函数 { return real; } friend MyClass operator+(MyClass&amp;,MyClass&amp;); void dis() { cout &lt;&lt; real &lt;&lt; “,” &lt;&lt; imag &lt;&lt; endl; }private: int real, imag;}; MyClass operator+(MyClass&amp;obj1,MyClass&amp;obj2){ MyClass obj; obj = obj1.real + obj2.real; obj = obj1.imag += obj2.imag; return obj;} int main(){ MyClass obj1(3),obj2; obj2 = obj1 + MyClass(3); //注意转换函数的使用是：类名（参数） obj2 = 3 + obj1; obj2 = obj1 + 3; obj2.dis(); MyClass obj(12,13); int a = 45; a = a + obj; a = obj + 56; cout &lt;&lt; a; system(&quot;pause&quot;); return 0; } //45////重载流提取和流输入 &lt;&lt; &gt;&gt; 重定向输出到文件 #include #include using namespace std; class MyClass{public: MyClass(int aa) :a(aa) {} friend istream &amp;operator&gt;&gt;(istream&amp;, MyClass&amp;); friend ostream &amp;operator&lt;&lt;(ostream&amp;, MyClass&amp;); private: int a;}; istream &amp;operator &gt;&gt;(istream&amp;mycin, MyClass&amp;obj1){ cout &lt;&lt; “输入一个整数：” &lt;&lt; endl; mycin &gt;&gt; obj1.a; return mycin;}ostream &amp;operator&lt;&lt;(ostream&amp;mycout, MyClass&amp;obj2){ mycout &lt;&lt; “这是一个对象输出:” &lt;&lt; obj2.a &lt;&lt; endl; return mycout;}int main(){ FILE *stream; //建立一个流对象作为freopen_s（）的第一个参数 freopen()无需第一个参数 freopen_s(&amp;stream,”test.txt”, “w”, stdout);//没有文件时自动建立 MyClass obj(666); cin &gt;&gt; obj; //还是要求从键盘输入 但不会在屏幕输出 cout &lt;&lt; obj; system(“pause”); return 0;} //46////存在派生类和的子对象的构造函数//顺序为：/基类子对象派生类 / #include #include using namespace std; class MyClass1{public: MyClass1(int aa): a1(aa){} void dis() { cout &lt;&lt; a1 &lt;&lt; endl; }private: int a1;}; class MyClass2:public MyClass1{public: MyClass2(int aa,int bb,int cc):MyClass1(aa),obj1(cc) { a2 = bb; } void dis() { MyClass1::dis();//若不加限定符存在二义性 cout &lt;&lt; a2 &lt;&lt; endl; obj1.dis(); }private: int a2; MyClass1 obj1;}; int main(){ MyClass2 obj2(23,26,666); obj2.dis(); system(“pause”); return 0;} //47////存在派生类和的子对象的构造函数//顺序为：/基类子对象派生类 / #include #include using namespace std; class MyClass3{public: MyClass3(int aa) :a3(),aa3(aa) {} void dis() { cout &lt;&lt; a3 &lt;&lt; endl &lt;&lt; aa3 &lt;&lt; endl; } int aa3;private: int a3;}; class MyClass1{public: MyClass1(int aa): a1(aa){} void dis() { cout &lt;&lt; a1 &lt;&lt; endl; }private: int a1;}; class MyClass2:public MyClass1{public: MyClass2(int aa,int bb,int cc):MyClass1(aa),obj1(cc),obj3(cc) { a2 = bb; } void dis() { MyClass1::dis();//若不加限定符存在二义性 cout &lt;&lt; a2 &lt;&lt; endl; obj1.dis(); obj3.dis(); }private: int a2; MyClass1 obj1; MyClass3 obj3;}; int main(){ MyClass2 obj2(23,26,666); obj2.dis(); //输出：23,26,666 0 666 ，知，无法对非基类的子对象进行访问私有数据 system(“pause”); return 0;} //48////虚基类的构造函数//虚基类：在继承间接共同基类时只保留一份成员 至少4个类之间的使用 #include #include using namespace std; class MyClass1{public: MyClass1(int aa): a(aa){}protected: //private时派生类无法访问 int a;}; class MyClass2:public virtual MyClass1 //virtual和public的顺序无所谓{public: MyClass2(int bb):b(bb),MyClass1(bb){}protected://private时派生类无法访问 int b;}; class MyClass3:virtual public MyClass1{public: MyClass3(int cc) :c(cc), MyClass1(cc) {}protected://private时派生类无法访问 int c;}; //class MyClass4:public MyClass2,public MyClass3 //和下一行写法不同但用法相同，加virtual是为了派生类不会产生不明确的继承，此处的MyClass4没有派生类 故无需添加virtualclass MyClass4 :public virtual MyClass2, virtual public MyClass3{public: MyClass4(int dd) :d(dd), MyClass1(dd),MyClass2(dd),MyClass3(dd) {} //此处要对基类的基类的构造函数MyClass1（int aa）初始化 void dis() { cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; d &lt;&lt; endl; } protected: int d;}; int main(){ MyClass4 obj(666); obj.dis(); system(“pause”); return 0;} //49////基类与派生类之间的转换 #include #include using namespace std; class MyClass1{public: MyClass1(int aa): a(aa){} int a;}; class MyClass2:public virtual MyClass1 //virtual和public的顺序无所谓{public: MyClass2(int bb):b(bb),MyClass1(bb){} int b;}; void f(MyClass1 &amp;obj){ cout &lt;&lt; obj.a &lt;&lt; endl; //cout &lt;&lt; obj.b; error 无法访问派生类的成员，即使调用时实参是MyClass2的对象} int main(){ MyClass2 obj(666); f(obj); system(“pause”); return 0;} //50////多态性的使用（虚函数）/类：点；线；正方形；正方体 / #include #include using namespace std; class point{public: point(double x,double y): a(x),b(y){} double a,b; void virtual dis() { cout &lt;&lt; “坐标为：(“ &lt;&lt; a &lt;&lt; “,” &lt;&lt; b &lt;&lt; “)” &lt;&lt; endl; }}; class line:public point{public: line(double x1,double y1,double x2,double y2):a(x1),b(y1), c(x2), d(y2), point(x1,y1){} double a,b,c,d; void virtual dis() { double k, m;//y=kx+m k = (b - d) / (a - c); m = b - k*a; if (m == 0) cout &lt;&lt; &quot;直线为：y=&quot; &lt;&lt; k &lt;&lt; &quot;x&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;直线为：y=&quot; &lt;&lt; k &lt;&lt; &quot;x+&quot; &lt;&lt; m &lt;&lt; endl; } }; class zhengfangxing:public line{public: zhengfangxing(int x,int y):a(y-x), line(x,y,x,y){} int a;//边长 void virtual dis()//面积 { double s;//y=kx+m s = a*a; cout &lt;&lt; “面积为：s=” &lt;&lt; s &lt;&lt; endl; }}; class lifangti :public zhengfangxing{public: lifangti(int x, int y) :a(y - x), zhengfangxing(x, y) {} int a;//边长 void virtual dis()//体积 { double v;//y=kx+m v = aaa; cout &lt;&lt; “体积为：v=” &lt;&lt; v &lt;&lt; endl; }}; int main(){ //一般使用 point obj1(666,44); line obj2(3, 8, 0, 1); zhengfangxing obj3(4,8); lifangti obj4(4,8); obj1.dis(); obj2.dis(); obj3.dis(); obj4.dis(); //使用虚函数（以下输出和上边完全相同） point *p; //基类指针分别指向不同的派生类 p = &amp;obj1; p-&gt;dis(); p = &amp;obj2; p-&gt;dis(); p = &amp;obj3; p-&gt;dis(); p = &amp;obj4; p-&gt;dis(); system(&quot;pause&quot;); return 0; } //51////多态性的使用（纯虚函数）/抽象基类：存在纯虚函数的基类 shape类：点；正方形；正方体 / #include #include using namespace std; class shape{public: virtual void point() { cout &lt;&lt; “点坐标为：” &lt;&lt; 0 &lt;&lt; “,” &lt;&lt; 0 &lt;&lt; endl; } virtual void area() { cout &lt;&lt; “面积为：” &lt;&lt; 0 &lt;&lt; endl; } virtual void v() { cout &lt;&lt; “体积为：” &lt;&lt; 0 &lt;&lt; endl; } virtual void shapeName() = 0;};class mypoint:public shape{public: mypoint(double x,double y): a(x),b(y){} double a,b; virtual void shapeName() { cout &lt;&lt; “this is a point. “ &lt;&lt; endl; point(); area(); v(); } void point() { cout &lt;&lt; “坐标为：(“ &lt;&lt; a &lt;&lt; “,” &lt;&lt; b &lt;&lt; “)” &lt;&lt; endl; }}; class myzhengfangxing:public shape{public: myzhengfangxing(int x,int y):a(y-x){} int a;//边长 void area()//面积 { double s;//y=kx+m s = a*a; cout &lt;&lt; “面积为：s=” &lt;&lt; s &lt;&lt; endl; } virtual void shapeName() { cout &lt;&lt; “this is a zhengfangxing. “ &lt;&lt; endl; point(); area(); v(); }}; class mylifangti :public shape{public: mylifangti(int x, int y) :a(y - x){} int a;//边长 void v()//体积 { double v;//y=kx+m v = aaa; cout &lt;&lt; “体积为：v=” &lt;&lt; v &lt;&lt; endl; } virtual void shapeName() { cout &lt;&lt; “this is a lifangti. “ &lt;&lt; endl; point(); area(); v(); }}; int main(){ //一般使用 mypoint obj1(666,44); myzhengfangxing obj2(4,8); mylifangti obj3(4,8); obj1.shapeName(); obj2.shapeName(); obj3.shapeName(); cout &lt;&lt; endl; //使用虚函数（以下输出和上边完全相同） shape *p; //基类指针分别指向不同的派生类 p = &amp;obj1; p-&gt;shapeName(); p = &amp;obj2; p-&gt;shapeName(); p = &amp;obj3; p-&gt;shapeName(); system(&quot;pause&quot;); return 0; } //52////main.cpp//头文件的使用 在classmypoint.h 中声明mypoint类 #include #include “classmypoint.h” //自己的头文件必须双引号using namespace std; int main(){ mypoint obj1(666,44); obj1.point(); system(“pause”); return 0;} classmypoint.h #include //此文件中用到的库要加到此文件的头文件using namespace std;class mypoint{public: mypoint(double x, double y) : a(x), b(y) {} double a, b; void point() { cout &lt;&lt; “坐标为：(“ &lt;&lt; a &lt;&lt; “,” &lt;&lt; b &lt;&lt; “)” &lt;&lt; endl; }}; //53////流对象控制输出 特殊函数（字符函数）输入输出 #include using namespace std; void f(char t){ //输出一个字符的两个函数 cout.put(65); //等价putchar(65); 等价cout.put(‘A’); cout.put(‘\n’); //输入函数get的3中用法 /cin.get();//①取一个字符，包括空白（空格） char ch; cin.get(ch);//②赋值给ch char str1[50]; cin.get(str1,7,’a’);//③赋值给str[]数组 参数分别是：指针 读取个数(n-1) 终止字符(不论是否达到终止个数，遇到结束符即刻终止) cout &lt;&lt; str1 &lt;&lt; endl; */ //char str2[50]; //cin.getline(str2, 7, ‘a’); //参数分别是：指针 读取个数(n - 1) 终止字符(不论是否达到终止个数，遇到结束符即刻终止) 输出时不包括终止字符 //cout &lt;&lt; str2 &lt;&lt; endl; //控制符 int a = 21; cout.setf(ios::showbase); //显示基数符号（0x 0） cout &lt;&lt; a &lt;&lt; endl; cout.unsetf(ios::dec);//终止10进制 cout.setf(ios::hex);//16进制 必须对10进制的设置终止，否则不起作用 cout &lt;&lt; a &lt;&lt; endl; cout.unsetf(ios::hex);//终止10进制 cout.setf(ios::oct);//8进制 必须对16进制的设置终止，否则不起作用 cout &lt;&lt; a &lt;&lt; endl; cout.width(10); //仅对一个输出变量有效 cout &lt;&lt; t &lt;&lt; t &lt;&lt; endl; //第一个t不足10位时左边自动以空格替代 cout.fill(&apos;*&apos;); cout.width(10); cout &lt;&lt; t &lt;&lt; t &lt;&lt; endl; //第一个t不足10位时左边以*替代 double b = 0.31415926; cout.setf(ios::scientific); cout &lt;&lt; b &lt;&lt; endl; cout.unsetf(ios::scientific); cout.setf(ios::fixed);//默认小数点后6位输出 cout &lt;&lt; b &lt;&lt; endl; cout.precision(20); cout.setf(ios::fixed);//小数点后10位输出 原数小于10时，0补充或取近似值 如1取为0.99999 cout &lt;&lt; b &lt;&lt; endl; cout.setf(ios::showpos | ios::right); cout &lt;&lt; b &lt;&lt; endl; } void f2(){ //eof char c; while (!cin.eof()) { c = cin.get(); if ( c == ‘a’) break; cout.put(c); }}int main(){ char t[111] = {“dfdgg”}; f(t); f2(); system(“pause”); return 0;} //54////文件操作 （ASCII 、二进制） #include #include using namespace std;/*f1()输入输出ASCIIf2()输入输出二进制f3()二进制的输入输出同时操作 及修改磁盘二进制数据后再次存放到磁盘 istream&amp; read(char buffer,int len)为从文件以二进制方式读出ostream&amp; write(const char buffer,int len)以二进制方式写入到文件*/ void f1()//对ASCII输出到文件{ ofstream outfile(“test.txt”,ios::out); //文件不存在会自动创建 若原来存在会覆盖 if (!outfile) { cerr &lt;&lt; “open error!” &lt;&lt; endl; exit(1); } outfile &lt;&lt; “dfsdf” &lt;&lt; endl &lt;&lt; 999; outfile.close();} void f11()//用 ASCII输入{ ifstream infile(“test.txt”,ios::in | ios::_Nocreate);//不创建新文件 若不存在则打开失败 if (!infile) { cerr &lt;&lt; “fail” &lt;&lt; endl; exit(1); } int a[2]; for (size_t i = 0; i &lt; 2; i++) //若与文件信息数据类型不匹配，出现意想不到的结果 { infile &gt;&gt; a[i]; cout &lt;&lt; a[i] &lt;&lt; endl; } infile.close();} void f12()//用 ASCII输入{ ifstream infile(“test.txt”, ios::in | ios::_Nocreate);//不创建新文件 若不存在则打开失败 if (!infile) { cerr &lt;&lt; “fail” &lt;&lt; endl; exit(1); } char ch; for (; infile.get(ch);) //空格 空行 均可读入 { cout.put(ch); } infile.close();} void f2()//二进制方式输出到文件{ struct student { char name[20]; int num; int age; }; student stu[2] = {“wang”,10086,18,”zhao”,10084,18 }; ofstream outfile(“stu.txt”,ios::binary); if (!outfile) { cerr &lt;&lt; “error…” &lt;&lt; endl; abort(); } outfile.write((char*)&amp;stu[0], sizeof(stu)); //stu[0]是起始地址 sizeof(stu)是整个结构体变量的大小 outfile.close();} void f21()//二进制方式输出到文件{ struct student { char name[20]; int num; int age; }; student stu[2]; ifstream infile(“stu.txt”, ios::binary); if (!infile) { cerr &lt;&lt; “error…” &lt;&lt; endl; abort(); } infile.read((char*)&amp;stu[0], sizeof(stu)); infile.close(); for (size_t i = 0; i &lt; 2; i++) { cout &lt;&lt; stu[i].name &lt;&lt; endl; cout &lt;&lt; stu[i].num &lt;&lt; endl &lt;&lt; endl; } } void f3(){ struct student { char name[20]; int num; int age; }; student stu[5] = { “q”,100,18,”w”,101,18 ,”e”,102,18,”r”,103,18 ,”t”,104,18}; fstream iofile(“stu.txt”, ios::binary | ios::in | ios::out); //ios::in | ios::out必须添加，否则无法操作 if (!iofile) { cerr &lt;&lt; “error…” &lt;&lt; endl; abort(); } //存入到磁盘 iofile.write((char*)&amp;stu[0], sizeof(stu)); //从磁盘文件读取第1，3，5个学生数据 student stu_1[5]; for (size_t i = 0; i &lt; 5; i+=2) { iofile.seekg(i*sizeof(stu[i]), ios::beg);//定位在1,3,5学生数据开头 iofile.read((char*)&amp;stu_1[i/2],sizeof(stu_1[0]));//读取存放 cout &lt;&lt; stu_1[i / 2].name &lt;&lt; &quot;,&quot; &lt;&lt; stu_1[i / 2].num &lt;&lt; endl; } //修改第3人的信息 /*stu_1[2].name = &quot;WTO&quot;;*/ //直接重新复制出错，应使用strcpy(str1,str2) strcpy_s(stu[2].name, &quot;WTO&quot;); stu[2].num = 666; iofile.seekg(2 * sizeof(stu[0]), ios::beg); //定位 iofile.write((char*)&amp;stu[2], sizeof(stu[2])); //写入更新 stu[2]为开始位置 iofile.seekg(0, ios::beg);//重定位到文件开头 iofile.read((char*)&amp;stu[0], sizeof(stu)); cout.put(&apos;\n&apos;); for (size_t i = 0; i &lt; 5; i++) { cout &lt;&lt; stu[i].name &lt;&lt; &quot;,&quot;; cout &lt;&lt; stu[i].num &lt;&lt; endl; } iofile.close(); } int main(){ //f1(); //f11(); //f12(); /*f2(); f21();*/ f3(); system(&quot;pause&quot;); return 0; } //55////文件操作2 #include #include using namespace std;/*要求①输入4个数，存放在两个文件（1.txt,2.txt），每个文件2个数②把1.txt中的2个数存放在2.txt后③对2.txt中的4个数排序，排序后从新存放到2.txt istream&amp; read(char buffer,int len)为从文件以二进制方式读出ostream&amp; write(const char buffer,int len)以二进制方式写入到文件*/ void f1()//ASCII方式{ int a; ofstream outfile(“1.txt”);//默认以ios::out if (!outfile) { cerr &lt;&lt; “error…” &lt;&lt; endl; abort(); } for (size_t i = 0; i &lt; 2; i++) { cin &gt;&gt; a; outfile &lt;&lt; a &lt;&lt; “ “; } outfile.close(); //不关闭直接打开下一个文件，提示error… outfile.open(&quot;2.txt&quot;);//默认以ios::out if (!outfile) { cerr &lt;&lt; &quot;error...&quot; &lt;&lt; endl; abort(); } for (size_t i = 0; i &lt; 2; i++) { cin &gt;&gt; a; outfile &lt;&lt; a &lt;&lt; &quot; &quot;; } outfile.close(); ifstream infile(&quot;1.txt&quot;); if (!infile) { cerr &lt;&lt; &quot;error...&quot; &lt;&lt; endl; abort(); } int t[2]; for (size_t k = 0; k &lt; 2; k++) { infile &gt;&gt; t[k]; } infile.close(); outfile.open(&quot;2.txt&quot;,ios::app); //打开文件，并使指针指向末尾 if (!outfile) { cerr &lt;&lt; &quot;error...&quot; &lt;&lt; endl; abort(); } for (size_t k = 0; k &lt; 2; k++) { outfile &lt;&lt; t[k] &lt;&lt; &quot; &quot;; } outfile.close(); infile.open(&quot;2.txt&quot;); if (!infile) { cerr &lt;&lt; &quot;error...&quot; &lt;&lt; endl; abort(); } int t2[4]; for (size_t k = 0; k &lt; 4; k++) { infile &gt;&gt; t2[k]; } infile.close(); int temp; //冒泡 for (size_t i = 0; i &lt; 4-1; i++) { for (size_t j = 0; j &lt; 4 - i - 1; j++) if (t2[j]&gt;t2[j + 1]) { temp = t2[j]; t2[j] = t2[j + 1]; t2[j + 1] = temp; } } cout &lt;&lt; &quot;排序后的数据：&quot; &lt;&lt; endl; for (size_t i = 0; i &lt; 4; i++) { cout &lt;&lt; t2[i] &lt;&lt; endl; } outfile.open(&quot;2.txt&quot;); //打开文件，重新写入，覆盖原有数据 if (!outfile) { cerr &lt;&lt; &quot;error...&quot; &lt;&lt; endl; abort(); } for (size_t k = 0; k &lt; 4; k++) { outfile &lt;&lt; t2[k] &lt;&lt; &quot; &quot;; } outfile.close(); } int main(){ f1(); system(&quot;pause&quot;); return 0; } //56////异常处理和命名空间 可以多个try catch 一个throw #include #include #include using namespace std;/知三角形三边求面积 /namespace myname{ void f1(double a, double b, double c)//面积求解 { double s = (a + b + c) / 2; if ((a + b &lt;= c) || (a + c &lt;= b) || (c + b &lt;= a)) throw a; cout &lt;&lt; “面积:” &lt;&lt; sqrt(s(s - a)(s - b)*(s - c)) &lt;&lt; endl; } void f2(int a) { try { if (a&lt;0)throw a; cout &lt;&lt; a &lt;&lt; endl; } catch (char b) { cout &lt;&lt; &quot;a error...&quot;; } } } using namespace myname;//只能在主函数前声明 不能在文件开头声明 int main(){ try { //f1(11, 78, 89); //只能捕获一个异常，即遇到异常就转到catch 不再执行以下内容 f2(-2); } catch (int a) //参数类型找不到时(不匹配)，等于没写 { cout &lt;&lt; “error…” &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;; } system(“pause”); return 0;} //57////运算符的优先级 #include #include #include using namespace std; void f(){ //优先级 //1.:: void MyClass::ff(); //类内声明成员函数 （MyClass可省略） //2.() [] -&gt; . ++(后置) –(后置) //3.++ – ~ ！ -(负号) +(正号) (指针) &amp;(取地址) (类型转换) sizeof new delete //4.(乘) % / //5.+(加) - //6.&lt;&lt;(按位左移) &gt;&gt; //7. &lt; &lt;= &gt; &gt;= //8.== != //9.&amp;(按位与运算) //10.^ (异或) //11.| (按位或) //12.&amp;&amp; //13.|| //14.三目 //15.赋值 = +=…… //16.throw //17., //级别判断（高—低）：初等运算符 单目 算术 关系 逻辑 条件 赋值 逗号 cout &lt;&lt; &quot;blank..&quot; &lt;&lt; endl; } int main(){ system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 年 9 月二级Office VIP软件]]></title>
    <url>%2F2019%2F09%2F12%2F9%20%E6%9C%88%E4%BA%8C%E7%BA%A7Office%20VIP%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[还有十几天开考，慌不慌？ 不慌，还有时间，今日发布最新题库替你救急。 （提供激活码） 1，Windows安装使用 双击exe后缀的安装包 win10 ，出现如下界面，点击【是】 全部默认安装，可以看到2019.9界面最新题库 点击小锁激活输入密码 两个考题库如下： 备考时间规划：15天是office二级最适宜的备考时间。但是大家可以先做一套完整的ppt、word、Excel感受一下，如果基础实在太差，亦或是学校课时安排太多以致无法保证每天的练习时间，可将15天稍微往上浮动3-7天，足以应考，反之亦然。 90分及以上通过计算机二级证书上标注为优秀 60-90分通过计算机二级证书上标注为合格。 虽然这二者在实际生活中并没有太大的区别，但是相对于其他考试的多一分浪费，少一分受罪，优秀的认定对于部分认真备考的同学来说还是可以起一定的激励作用。 这些你需要知道：1，模拟套题就是真题，只是有细微差别 2，时间紧迫，无需全部练习，会做的直接跳过 3，新增题库抽中的比率大，多做几遍 4，多总结Excel部分的公式用法 5，PPT动画部分，透视图部分一般会涉及到 6，工作学习都会用到office知识 7，推荐网易的秋叶大师的office 8，往期推送有相关的高级应用 9，考试仅仅是基本操作，几天就看完了 10，仅想通过考试，这款模拟软件足矣 考场问题：1.由于二级会有部分选择题需要演算，请在考试时带好笔，草稿在准考证背面打就ok。 2.考试时可能会有一些突发情况，如做到一半电脑死机，每年都有发生，请及时向监考老师反映。 获取： 微信【随心下呀】后台回复【201909】 输入压缩包的破解密码直接可用]]></content>
      <categories>
        <category>资源</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JAVA全套学习资料]]></title>
    <url>%2F2019%2F05%2F02%2Fjava%2F</url>
    <content type="text"><![CDATA[JAVA全套学习资料，要的点进来 JAVA全套学习资料分享说明 由于资料（文件）过多，分享链接随时面临“和谐” 由于使用国外图床，本站的图片，必要情况无法加载 想学好 300集视频，认真学，找工作可以应付了 认真敲命令 链接: https://pan.baidu.com/s/1tHo0ZeqIfy3VMJJDggy-jg 提取码: 6666]]></content>
      <categories>
        <category>资源</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MATLAB全套学习资料]]></title>
    <url>%2F2019%2F05%2F02%2FMATLAB%2F</url>
    <content type="text"><![CDATA[深度学习必备 MATLAB全套学习资料分享说明 由于资料（文件）过多，分享链接随时面临“和谐” 由于使用国外图床，本站的图片，必要情况无法加载 想学好 版本很老，但，实用，讲的非常详细，适合新手学习 2018年学习它，数学建模国家二等奖 认真敲命令 链接: https://pan.baidu.com/s/1P3nTT1Xbva9uyG-P3j_QGA 提取码: 6666]]></content>
      <categories>
        <category>资源</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C#源码分享]]></title>
    <url>%2F2019%2F05%2F02%2FC%23%2F</url>
    <content type="text"><![CDATA[C#可视化编程来了 C#源码分享分享说明 由于资料（文件）过多，分享链接随时面临“和谐” 由于使用国外图床，本站的图片，必要情况无法加载 想学好 认真敲命令 链接: https://pan.baidu.com/s/1JZgNOLr9WhWGpQ8ktuhi6Q 提取码: 6666]]></content>
      <categories>
        <category>资源</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[软考网络规划师资料]]></title>
    <url>%2F2019%2F05%2F02%2F%E8%BD%AF%E8%80%83-%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E5%B8%88%E6%95%99%E6%9D%90%2F</url>
    <content type="text"><![CDATA[华为越来越牛逼了，考试命令都是华为了。 个人经验 150报名费泡汤了，规划师需要实际的项目经验，不然论文3000字怎么凑啊啊啊啊啊啊啊 软考网络规划师资料分享说明 由于资料（文件）过多，分享链接随时面临“和谐” 由于使用国外图床，本站的图片，必要情况无法加载 想学好 看看上一篇分享的【华为】资料 链接: https://pan.baidu.com/s/18ciRZQ4gN_KZLYLyp4lq1w 提取码: 6666]]></content>
      <categories>
        <category>资源</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[软考网络工程师教材]]></title>
    <url>%2F2019%2F05%2F02%2F%E8%BD%AF%E8%80%83-%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%95%99%E6%9D%90%2F</url>
    <content type="text"><![CDATA[华为越来越牛逼了，考试命令都是华为了。 软考网络工程师教材分享说明 由于资料（文件）过多，分享链接随时面临“和谐” 由于使用国外图床，本站的图片，必要情况无法加载 想学好 看看上一篇分享的【华为】资料 链接: https://pan.baidu.com/s/1UqK2GYDJUZDV1EjozTPSJA 提取码: 6666]]></content>
      <categories>
        <category>资源</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于本站访问速度问题]]></title>
    <url>%2F2019%2F05%2F02%2F%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[几点重要说明 关于本站访问速度问题说明 博主比较忙，看心情更新 分享的资料失效，你在下面留言，我看到了就更新修复 网站自动生成，没有过多优化，访问较慢，进不来刷新即可 其他 由于资料（文件）过多，分享链接随时面临“和谐” 由于使用国外图床，本站的图片，必要情况无法加载 个人网盘 http://yg2015062.gz01.bdysite.com/public/ 密码：lvcha]]></content>
      <categories>
        <category>资源</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[尤克里里资源]]></title>
    <url>%2F2019%2F05%2F02%2F%E5%B0%A4%E5%85%8B%E9%87%8C%E9%87%8C%2F</url>
    <content type="text"><![CDATA[从菜鸟–&gt;高手的必备 尤克里里资源分享说明 由于资料（文件）过多，分享链接随时面临“和谐” 由于使用国外图床，本站的图片，必要情况无法加载 链接: https://pan.baidu.com/s/1toik1emy3nPXZN7yBZqqgA 提取码: 6666]]></content>
      <categories>
        <category>资源</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[华为网络资源]]></title>
    <url>%2F2019%2F05%2F02%2F%E5%8D%8E%E4%B8%BAeNSP%2F</url>
    <content type="text"><![CDATA[华为越来越牛逼了，。 华为网络资源分享说明 由于资料（文件）过多，分享链接随时面临“和谐” 由于使用国外图床，本站的图片，必要情况无法加载 链接: https://pan.baidu.com/s/1FJiPGPfelAx7bIlDmPWpkg 提取码: 6666]]></content>
      <categories>
        <category>资源</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[32套MBE风格PPT模板]]></title>
    <url>%2F2019%2F05%2F02%2F32%E5%A5%97MBE%E9%A3%8E%E6%A0%BCPPT%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[又一波PPT，收藏起来 32套MBE风格PPT模板分享说明 由于资料（文件）过多，分享链接随时面临“和谐” 由于使用国外图床，本站的图片，必要情况无法加载 http://t.cn/EoHWGE8备用：链接: https://pan.baidu.com/s/1M2p0QCI2Qv-kLx4NoIQivA 提取码: 6666]]></content>
      <categories>
        <category>资源</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[大数据61GB资源]]></title>
    <url>%2F2019%2F05%2F02%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[从菜鸟–&gt;高手的必备 大数据61GB资源分享说明 由于资料（文件）过多，分享链接随时面临“和谐” 由于使用国外图床，本站的图片，必要情况无法加载 链接: https://pan.baidu.com/s/1btNxOBTWiUMZ8AYYZ9WPdA 提取码: 6666]]></content>
      <categories>
        <category>资源</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[360套简历模板]]></title>
    <url>%2F2019%2F04%2F18%2F360%E5%A5%97%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[360套简历模板 链接: https://pan.baidu.com/s/1k1x0FGFgSt8XPs2RStG9gw 提取码: 6666]]></content>
      <categories>
        <category>资源</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP学习资源]]></title>
    <url>%2F2019%2F04%2F17%2FPHP%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Decrypt U2FsdGVkX1/Nt7NpbEn1hel2hLrpxXiYuSF6m5EpgVPUg4Y24tWnAVDpQIDFNOd3vhxDuVGvDKBteLdp277I+85ozxTjM8gsXznFW3FP+sw6IHA3Xlh+8+ABGSLlmlYsA2efrfvGf8plqX02kNVlhWH2PKpnOrZ+jAd4513d1hMSATSQfowtDAaL8s1Ugps8CkeZ5ZByO5OK1Xc0ffOtKRQ6EyD/PBOwxb/JJTnbmUkVLcZnfmGnDur0hCKsa2aI/nfTQfjg9AHRb92SUpWmeZ2UNjbl1T1ugpAhggZ8NwOQvu4trJyGfutdXYvWFas1vi4Y9In7bIVLTm27+fjGfUpP5L2ULoSsR8cFdz+Ioc+R9sgx/U46GVpPv+a02U7KpN5xLlnsxVXEL6FQ7NvU7xh8HQBkOaUn+4HoxFNCd6RC4DSKGWQ4SHoLAFcav9ZnUApIP8TiCSOPX26krMAboHQhXFphJIO+JhdXiaa20mu4D53tZDImg0KAkV/F1Q5GBbPGY6+KcGZWD9NQcbS7BIGFqbcNwBBDjXZxC8Lzx2Ap7ksWSdX7sROFRuXQkXFAmTUHEvDVY8fp1tY+Odu3yFs04E1mhuLmB4KwHZ5epJcOmcd1wg+r0IAPdU9Jd1m26xzQA3dqI7DdE8HAM8nmnQ==]]></content>
      <categories>
        <category>资源</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[全排列算法+]]></title>
    <url>%2F2019%2F04%2F14%2F%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95-1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数组排序]]></title>
    <url>%2F2019%2F04%2F14%2F%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[题目要求：1，给定数组，要求把数组中的所有0输出到数组末尾，并保持原来非零元素的顺序不变；2，不能拷贝额外的数组；尽可能少的操作次数 领悟： 弄清逻辑关系很重要 方法1中交换是从第一个0开始交换的，此时的数组元素不为零，判断结构else..else if 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/*下面用两种方法实现*/#include&lt;iostream&gt;using namespace std;void function1(int str[],int n)&#123; int i,m=0;//m为0的个数 for(i=0;i&lt;n;i++) //统计0的个数 if(str[i]==0) m++; else if(m!=0) //从第一个0开始交换 &#123; str[i-m]=str[i];//数组元素不为零时跟当前第一个0元素所处的位置交换 str[i]=0;//交换后置为0 &#125; for(i=0;i&lt;n;i++) //打印输出排序后的值 printf(&quot;%d\t&quot;,str[i]);&#125;void function2(int str[],int n)&#123; int n1=0,n2=0,i=0; //n1、n2相当于两个指针 while(n2&lt;n) &#123; if(str[n2]!=0) //当前元素不为零，把当前元素复制到“0”所处的位置 &#123; str[n1]=str[n2]; n1++;// n和n1的差值为0的个数，即从下标n1~n应当元素值为0 n2++; &#125; else &#123; n2++;//向后推移 &#125; &#125; for(i=n1;i&lt;n;i++)//下标n1~n应当元素值为0 &#123; str[i]=0; &#125; for(i=0;i&lt;n;i++)//打印输出 &#123; printf(&quot;%d\t&quot;,str[i]); &#125;&#125;int main()&#123; int n,str[]=&#123;1,1,0,0,8,6,9&#125;; n=sizeof(str)/(sizeof(str[0]));//数组长度值 printf(&quot;方法1输出：\n&quot;); function1(str,n);//传参，数组，数组长度 printf(&quot;\n方法2输出：\n&quot;); function2(str,n); return 0;&#125; 输出结果：]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5分钟开发一款自己的App]]></title>
    <url>%2F2019%2F04%2F14%2Fappdev%2F</url>
    <content type="text"><![CDATA[前提说明各大商店的应用程序已经是琳琅满目，今天终于做个了自己的APP，全程5分钟搞定。这个是我搞的，比较粗糙，仅生成了Android的安装包，IOS安装起来不是那么方便。扫一扫下载体验： 流程如下 登录APP制作网站http://www.appcan.cn/ 填写后台支撑网站（web APP) 填写相关信息，包括你的应用名字，图标 生成应用 开发这里主要功能是把一个网页（我的网页）用最少功能的浏览器（平台开发工具）加载显示出来，相当于一个浏览器的书签，而外观上又比书签要高大上甚多，因为这是一个独立的APP呀。 其次，假如初始化时嵌入的网页是一个导航界面，这款“APP”就是过功能软件了，相当于微信里有大量小程序，不会占用额外的内存来加载资源。 这里只是运用了APPCan开发平台的一个最基本（个人感觉最耐用）的功能，平台具有自身的IDE，满足多功能的需求，当然，这个就不是5分钟能解决的了，需要你的编程、语言开发能力。 优点 简单、易上手 同时生成IOS和Android，无平台限制 制作过程注册账号，登录开发，详细过程已经标注，基本上都截图了。 APP启动图片来源1https://unsplash.com 总结说明 这类开发网站还有很多，不一一说了 个人网盘 http://yg2015062.gz01.bdysite.com/public/ 基于API开发（包括web APP）同样挺好用 https://www.apicloud.com/ 下边这本书，我这里的PDF电子版本只有部分内容，等于说只有目录，但可供参考，我放在个人网盘了 HbuilderX 这个上边大佬较多，目前已经做好（许多和真实APP无异的web APP应用已被开发），我给他定义是“全球最大不占内存的手机应用产地” http://www.dcloud.io/ 转载说明原创内容，如有侵权，请留言学习交流，有任何问题，请留言]]></content>
  </entry>
  <entry>
    <title><![CDATA[四六级]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%9B%9B%E5%85%AD%E7%BA%A7%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[资料说明搜集了四六级资源，好好珍惜。 链接链接: https://pan.baidu.com/s/1CJlRjUV-bscxVkDqw4CCPw 提取码: 6666]]></content>
  </entry>
  <entry>
    <title><![CDATA[全排列简单算法]]></title>
    <url>%2F2019%2F04%2F10%2F%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[全排列说明：以递归实现元素的所有组合，例如，有序列abc，全排列为abc、bac、cba、acb、bca、cab。对于bac、cba即abc的第一个元素分别与后边的各个元素交换；acb即abc的第二个元素与后面元素交换；bac、cab即bac、cba的第二个元素与后面元素交换所得。此时，即有全排列定义–从第一个元素起每个元素分别与他后边的元素进行交换。 //详细C++代码如下：//vc6++不支持cout中文输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;//#include &lt;algorithm&gt;using namespace std;//交换功能函数void Swap(char *a, char *b)&#123; char temp = *a; *a = *b; *b = temp;&#125;//全排列函数void AllRange(char *str, int k, int m)&#123; int i; if(k==m) &#123; static int a_i = 1; cout &lt;&lt; &quot;第&quot; &lt;&lt; a_i++ &lt;&lt; &quot;个排列是&quot; &lt;&lt; str &lt;&lt; &quot;\n&quot;; &#125; else &#123; for(i=k; i&lt;=m; i++) &#123; Swap(str+i,str+k); AllRange(str,k+1,m); Swap(str+i,str+k); &#125; &#125;&#125;void Foo(char *str)&#123; AllRange(str,0,strlen(str)-1); &#125;int main()&#123; cout &lt;&lt; &quot;全排列实现：&quot;; char qstr[] = &quot;123&quot;; Foo(qstr); system(&quot;pause&quot;); return 0;&#125; 解读语句AllRange(str,k+1,m);为递归函数，包括回溯和递推两部分。k=0开始，每次递归，k往前推移，直到所有元素完成全排列]]></content>
  </entry>
  <entry>
    <title><![CDATA[小书匠编辑器]]></title>
    <url>%2F2019%2F04%2F09%2F%E5%B0%8F%E4%B9%A6%E5%8C%A0%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[欢迎使用小书匠编辑器]]></content>
  </entry>
  <entry>
    <title><![CDATA[PPT模板]]></title>
    <url>%2F2019%2F04%2F09%2FPPT%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Decrypt 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]]></content>
  </entry>
  <entry>
    <title><![CDATA[GitHub+Hexo搭建自己的Blog 细节说明]]></title>
    <url>%2F2019%2F04%2F08%2FGitHub%2BHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Blog%20%E7%BB%86%E8%8A%82%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[前提说明：这里环境为Windows。 之前安装过GitHub+Hexo环境，由于重装系统，环境自然还得重新搭建，而之前的配置也是花了好几天，要是再弄一遍，实在麻烦。网上详细的教程也很多，可是也都纷说不同，我自己部署的过程中还是遇到了不少坑。下面详细说说自己安装了好几遍的经验和重点步骤的注意问题。 0，所有操作和命令无特殊说明都在自己的新建文件夹中进行，特别说明的是安装hexo时文件夹要为空1，Git对GitHub的账户名字的大小写是敏感的，一定要注意，重装环境的时候极其重要！！！2，GitHub Page文章的密码设了之后避免整个网站来回访问都要输入3，不绑定域名默认站点不安全，QQ或者微信无法直接访问，浏览器里报“不安全”4，生成的这个id_rsa.pub，复制到GitHub后要是没有生效就再在本地生成一个5，一般来说，普通用户环境下安装也能成功6，站点搜索功能，有local、algolia，启动其一不会出现问题7，提交代码时（hexo g 或 hexo d）无异常，能提升站点的整体访问速度，无“不安全”因素8，再次配置时，主题文件夹不能全盘复制，会出现渲染错误，只需把配置文件用原来的替换（可能不对）9，执行下面的命令后，在第一次使用hexo d上传代码时自动跳出GitHub的登录界面（win10） git config –global user.email “you@example.com“ git config –global user.name “Your Name” hexo搭建流程 注册GitHub，创建自己的仓库（用户名.github.io） 本地环境部署（node，git） 仓库创建没什么坑 不做重点，略过 本地环境（坑） 安装git下载Windows的版本，官网把资源放在亚马逊服务器了，下载速度极慢，网上搜了个Git_v2.21.0，解压出来一路next，安装到最后会运行，出现黑色窗口，不用管，关闭即可。 安装node官网速度依旧很慢，但是比Git好很多，由于我是安装git的时候开始下载的，git安装完毕正好node下载完毕，省了不少时间。同样，一路next，最后关闭安装窗口。 检测一下是不是装好了，用下面两个命令即可： 12Node –vNpm –v 出现版本号就说明成功了 安装hexo注意了，这里我先建的文件夹，就是运行npm i hexo-cli –g之前先建个项目的目录，直接用管理员的方式安装到这里就行。 安装hexo初始化同样，这里安装还是刚才的目录，不要切换，管理员身份运行hexo初始化命令hexo init，最后检测一下，命令： 1Hexo –v 进入新创建的目录 之前的配置很完美，重用拷贝之前安装hexo目录的全部内容，我这里把现在新生成的文件全部替换了，后面看来显然不行 本地搜索功能配置 自己的hexo文件根目录执行安装命令 1npm install hexo-generator-searchdb --save 根目录下 1/theme/next/_config.yml 启动配置 12local_search: enable: true 添加配置 12345search: path: search.xml field: post format: html limit: 10000]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux、Windows、IOS、Android之间局域网共享]]></title>
    <url>%2F2019%2F04%2F08%2F%E5%B1%80%E5%9F%9F%E7%BD%91%E7%B2%BE%E7%81%B5--%E4%B8%BA%E4%BD%A0%E8%8A%82%E7%9C%81%E6%B5%81%E9%87%8F%2F</url>
    <content type="text"><![CDATA[（Windows、Mac、Android使用教程） 前言 手机之间传文件想必用的最多的就是QQ面对面快传；手机和电脑之间传文件最方便的可能还是QQ（微信），手机电脑可访问外网时比较方便，但传输的需要发送和接收，加上文件过大且网速不好就扎心了，当然也可以在电脑端开启服务器功能，在手机端也可以开启远程控制功能；其他平台之间互传亦是这个方法。 但是开启网络共享的方法一般比较麻烦，比如Windows端文件共享可以安装有关服务器的软件，自带的共享功能要关闭防火墙或者设置家庭组… 今天介绍的工具完美解决局域网文件共享的问题，在没有WiFi，没有数据线时，就可在两个设备之间进行传输数据，甚至于在没有网络（外网）时进行传输！ 手机端文件共享 点击APP内分享图标，可以选择文件。分享APK安装程序，一般使用QQ面对面（只要手机安装了相关程序就能分享） 具体使用过程非常简单，就是手机打开热点，另一台设备（不一定是电脑）连接热点，这样就形成了一个简单的局域网。然后在其他设备中的浏览器输入软件最上面的 IP 地址，即可以连接，并手机和电脑互传文件。但是建议手机关闭移动数据，这样的话确保不会走流量（因为后台其他软件可能消耗流量）。 要==强调==的是，现在在局域网精灵在选择文件的时候也可以传APP安装程序，方便了很多。在任何局域网内的设置都可以用浏览器通过IP地址进入分享的页面，可以下载、也可以上传。这些文件所有人都共享。 注：当客户端关闭后，这些分享的内容自然也会失效。 Windows详细使用教程 1、打开下载好的[局域网共享精灵]软件； 2、“设置主页”选择[否]； 3、打开[设置向导]； 4、选择共享方式； 5、添加共享的文件夹或磁盘路径； 6、例如，选择一个共享文件夹； 7、设置一个共享名字； 8、然后点[下一步]； 9、[完成]共享； 图示流程： Linux: 安装步骤 1.把下载的文件解压: 1sudo tar xvf langenius-linux-amd64.tar.bz2 -C /opt 2.安装 12cd /opt/langeniussudo ./install.sh 3.让它可以在任何位置被执行 1sudo ln -s /opt/langenius/langenius /usr/bin 4.开始分享你的文件到局域网上面吧! 1langenius ./a.txt 资源获取：下载链接 ==更多精彩微信关注：随心下（Suixinxia007）==]]></content>
      <categories>
        <category>实用软件</category>
      </categories>
      <tags>
        <tag>LAN</tag>
        <tag>WLAN</tag>
        <tag>省流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[资源汇总]]></title>
    <url>%2F2019%2F04%2F08%2F%E5%85%AC%E4%BC%97%E5%8F%B7%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[公众号内资源提供 音乐篇 酷我VIP 国际版抖音 制作抖音 酷狗VIP 音乐湖 音乐侠 全网版(网页) 酷我VIP(新) 视频 影迷大院 视频剪辑 视频转换 格式工厂 PotPlayer 播放 图片 高清图 资源搜索 资源搜索1 资源搜索2 下载工具 百度网盘(部分账号限速) 学生福利篇 后台回复下列括号内关键字获取 期中期末成绩查询（在校成绩） 英语四六级成绩查询 计算机等级考试查询 毕业论文查重 资料学习篇 一级WPS 一级Office 一级PS 二级C语言 二级C++ 二级Java 二级Python 二级VB 二级MySQL 二级Access 二级Web 二级C语言(新) 二级Office 三级嵌入式 三级数据库 三级网络 三级信息安全 三级网络(旧) 四级嵌入式 四级数据库 四级网络 四级信息安全 等考所有科目 英语听力 数学建模 网络工程师备考1 网络工程师备考2 网络工程师备考(附加) 编程研究篇 Excel表格大神 SPSS Python 桌面篇 屏幕扩展 MacOS-Office Windows-Office 牛人截图 除片水印 ####|||||:——:|:——:|:——:||||||||| 技术篇 蚂蚁森林能量自动收取 局域网文件共享 带你了解浏览器2 带你了解浏览器1]]></content>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text3常用快捷键]]></title>
    <url>%2F2019%2F04%2F08%2FSublime%20Text3%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[SublimeText是前端的一个神器，以其精简和可DIY而让广大fans疯狂。首先是安装，如果你有什么软件管家的话搜一下就好，此处提供绿色版,既然是神器，肯定有你不知道的东西不是，下面这部分来讲操作。PS：部分图片和文字来自网络。测试操作系统：Win10测试软件版本：Sublime Text 3 选择类1234567891011121314151617181920212223Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。Ctrl+M 光标移动至括号内结束或开始的位置。Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。Ctrl+Shift+] 选中代码，按下快捷键，展开代码。Ctrl+K+0 展开所有折叠代码。Ctrl+← 向左单位性地移动光标，快速移动光标。Ctrl+→ 向右单位性地移动光标，快速移动光标。shift+↑ 向上选中多行。shift+↓ 向下选中多行。Shift+← 向左选中文本。Shift+→ 向右选中文本。Ctrl+Shift+← 向左单位性地选中文本。Ctrl+Shift+→ 向右单位性地选中文本。Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。 编辑类12345678910111213141516Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。Ctrl+Shift+D 复制光标所在整行，插入到下一行。Tab 向右缩进。Shift+Tab 向左缩进。Ctrl+K+K 从光标处开始删除代码至行尾。Ctrl+Shift+K 删除整行。Ctrl+/ 注释单行。Ctrl+Shift+/ 注释多行。Ctrl+K+U 转换大写。Ctrl+K+L 转换小写。Ctrl+Z 撤销。Ctrl+Y 恢复撤销。Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。Ctrl+F2 设置书签Ctrl+T 左右字母互换。F6 单词检测拼写 搜索类Ctrl+F 打开底部搜索框，查找关键字。 Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。 Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。 Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。 Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。 Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。 Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。 Esc 退出光标多行选择，退出搜索框，命令框等。 ## 搜索类 显示类Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。 Ctrl+PageDown 向左切换当前窗口的标签页。 Ctrl+PageUp 向右切换当前窗口的标签页。 Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字） Alt+Shift+2 左右分屏-2列 Alt+Shift+3 左右分屏-3列 Alt+Shift+4 左右分屏-4列 Alt+Shift+5 等分4屏 Alt+Shift+8 垂直分屏-2屏 Alt+Shift+9 垂直分屏-3屏 Ctrl+K+B 开启/关闭侧边栏。 F11 全屏模式 Shift+F11 免打扰模式]]></content>
  </entry>
  <entry>
    <title><![CDATA[Autojs--蚂蚁森林能量自动收取&QQ自动点赞]]></title>
    <url>%2F2019%2F04%2F08%2FAutojs--%E8%9A%82%E8%9A%81%E6%A3%AE%E6%9E%97%E8%83%BD%E9%87%8F%E8%87%AA%E5%8A%A8%E6%94%B6%E5%8F%96%26QQ%E8%87%AA%E5%8A%A8%E7%82%B9%E8%B5%9E%2F</url>
    <content type="text"><![CDATA[前言 前段时间了解了nodejs，近几天有了解到一个新奇好玩的autojs。用过Excel宏命令的朋友知道，就是利用脚本代码实现自动化模拟动作进行功能实现，autojs其实一样，用自动化计算机语言成为安卓系统的一个“辅助”功能。 项目地址==GitHub==https://github.com/autojshttps://github.com/hyb1996/Auto.js==APK下载==https://www.coolapk.com/apk/org.autojs.autojs 功能 1. 手机无需root实现自动阅读新闻、自动点赞、自动评论、自动收集支付宝能量；2. 实现自动打开应用，自动点击、滑动、输入文字等；可用于编写游戏脚本，自动做任务实现自动打开应用，自动点击、滑动、输入文字等；3. 可用于编写游戏脚本，自动做任务可用于编写游戏脚本，自动做任务4. 完成繁琐任务，最终解放你的双手最终解放你的双手QQ自动点赞- 这里以QQ自动点赞为例，最新版支付宝蚂蚁森林能量收集点击此处获取 直达- QQ自动点赞使用教程1. Android手机安装Autojs（系统版本最好7.0以上）并打开无障碍功能2. 保存下边的代码为js后缀的文件，用autojs打开运行即可3. 手动定位到点赞页面将快速点赞- 点赞代码1234567891011121314151617181920212223242526272829303132 &quot;auto&quot;;var 延迟 = 200;function 下滑()&#123;className(&quot;AbsListView&quot;).scrollable().scrollForward();&#125;function 赞()&#123;className(&quot;ImageView&quot;).desc(&quot;赞&quot;).untilFind().each(function(item)&#123;for(var i = 0; i &lt; 10; i++)&#123;item.click();sleep(延迟);&#125;&#125;);&#125;function 显示更多()&#123;for(let i = 0; i &lt; 2;i++)&#123;click(&quot;显示更多&quot;);&#125;&#125;toast(&quot;请打开自己的资料页，点击点赞图标&quot;);sleep(1000);while(notStopped())&#123;赞();显示更多();下滑();&#125;更多代码或功能参看==APP中教程模块==或参考以下==链接==：1. https://github.com/hyb1996/Auto.js2. https://blog.csdn.net/c0411034/article/details/840987643. https://blog.csdn.net/kimipoker/article/details/798452614. https://tieba.baidu.com/f?kw=autojs参考博客：[^1]https://blog.csdn.net/Soinice/article/details/82698875 ==更多精彩微信关注：随心下（Suixinxia007）==]]></content>
      <categories>
        <category>自动做任务</category>
      </categories>
      <tags>
        <tag>Autojs</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小白用utool实现内网穿透(0元)~]]></title>
    <url>%2F2019%2F02%2F09%2F%E5%B0%8F%E7%99%BD%E7%94%A8utool%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F-0%E5%85%83%2F</url>
    <content type="text"><![CDATA[utool–官网社区是这么说的utools是一款极简、插件化、跨平台的现代桌面软件，只有一个简单的输入框，你可以在任何时候通过全局快捷键快速打开它。 的确，内网穿透功能只是插件中的一个功能，但今天具体谈内网穿透，其他功能可到utool官网下载使用。 除了快速启动程序外，我们日常工作中也会有各种各样的小需求，比如翻译一个单词、识别/生成二维码、查看颜色值、字符串编码/解码、图片压缩等等。uTools 将各种功能以插件形式聚合起来，变成你的专属小工具库，你只需敲入一个“快捷短语”，就能快速使用这些功能……最早接触的内网穿透软件是花生壳，官网说的很好，体验版也要收费（6块钱体验一把）。当然收费的质量有保障，提供的服务自然要好些，这也并不是说其他相类似的软件就差，只不过既然付了费体验效果肯定有些差异。 utool的内网穿透简单易用，无任何收费。uTools 里的内网穿透插件似乎是由 uTools 自家提供的的服务，能支持 http 协议转发、本地目录映射、tcp 协议转发。可以方便的通过本地代码调试公众号、小程序，也可以便捷的将本地目录变成一个静态服务器。 它提供了三种功能。下面详细说说这几项功能的作用 http服务即常规把内网IP转化为外网IP，可供外网来访问本机资源 本地目录即指定一个磁盘目录来供外网访问，需要注意的是只能访问静态网页 tcp服务实测未成功~~「一切皆插件」也让 uTools 拥有了无限的生命力，可以预计在未来越来越多的插件出现，会使得 uTools 变成一个全能的效率利器，最重要的是，你可以根据自己的需求挑选安装，让其成为你最趁手的工具合集，为各种日常操作提供大大的便利。 点击查看DuckChat搭建 下载 官网：https://u.tools 公众号：随心下呀 回复 utool]]></content>
      <tags>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown排版微信公众号文章]]></title>
    <url>%2F2019%2F02%2F01%2FMarkdown%E6%8E%92%E7%89%88%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[前言==更多精彩微信关注：随心下（Suixinxia007）== 大家知道，CSDN博客可以采用Markdown来写一篇文章，易于上手而且排版效果很赞，而发布微信公众号文章却不支持Markdown文件，一般一篇文章排版时间比码字花的时间还多。 常用排版工具 常用的微信文章发布插件有【新媒体管家】、【135编辑器】、【365编辑器】 其中新媒体管家作为浏览器插件，支持doc、docx文档直接上传，缺点是格式会错乱； 另外两个用于文章编写，同在公众平台里编写相同，优点是可以选用大量的模板和插件，编写好的文章可以同步或拷贝到公众平台，但仅限简单复制。写了一篇好的文章再想发布到其他平台就要再次排版，很让人蛋疼啊。 目前微信公众号的编辑器是不支持Markdown语法的，那怎么办呢？为解决这个问题，有一款叫Markdown Here的插件非常实用（支持Chrome、Firefox、Safari）。下面详细介绍神器–==Markdown Here==。 实验工具 一个写好的md文件（你要发布的公众平台文章） Chrome浏览器（或Firefox、Safari，我用的是Chrome） markdown-here插件①插件官网：https://markdown-here.com/②官网把插件放在谷歌了，不方便翻墙的小伙伴点击这里下载 公众平台新建一篇图文 使用 Chrome安装插件（安装方法不再赘述） 复制写好的==md文件内容==到公众平台新建图文页面 格式看着乱不要紧，==左键点击一下==安装好的插件(下图第二个图标) 再看下边的文章，是不是一下让你耳目一新了： &lt;完&gt; 想要深入体验这款插件的小伙伴可以看看这篇文章： Markdown标记语言+CSS+MarkdownHere ==更多精彩微信关注：随心下（Suixinxia007）==]]></content>
  </entry>
  <entry>
    <title><![CDATA[GitHub+Hexo搭建自己的Blog之(1)-环境搭建]]></title>
    <url>%2F2019%2F02%2F01%2FGitHub%2BHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Blog%E4%B9%8B(1)-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[万丈高楼平地起，对于搭建Blog来说，环境的部署就是这高楼的基石，下面我们来看看怎么部署环境。==更多精彩微信关注：随心下（Suixinxia007）==步骤总览 测试平台：Windows10Git环境 如果您还没有注册GitHub，先到官网 GitHub注册教程 看注册教程，这里不赘述了。 安装Git 点我下载 选择适合自己计算机环境的版本下载，我这里是Windows 10 环境，下载后，根据提示点next一步步安装即可。关于Git的更多使用技巧，推荐看廖雪峰老师的Git教程 点我学习 Node环境 安装Node.js 点我下载 同样选择适合自己计算机系统的版本下载安装即可。更多Node.js教程 点我学习 安装完毕后，测试是否安装成功，打开命令终端，我这里是Windows，win+r输入cmd进入终端，键入命令node -v 或者直接输入node回车即可，如果出现下图显示则说明node环境安装成功：（任意位置均可查看，因为配置的为全局变量） node中集成了npm包安装工具，输入命令npm -v查看版本号，如图：（任意位置均可查看，因为配置的为全局变量） Hexo环境 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装hexo-cli：进入终端，键入命令 npm i hexo-cli -g [其中 ‘npm’可用 cnpm，安装速度更快； ‘i’ 表示install， ‘-g’表示全局安装(注意：如果安装失败，建议在管理者模式下安装)] 初始化：在本地合适的位置创建一个文件夹用作Blog环境，比如，我这里创建了一个hexo文件夹，进入此目录，按住 shift 键同时点击鼠标右键打开Powershell终端（cmd命令也可以），键入命令 hexo init 进行初始化，进度可能很慢[蹲个厕所回来大概就OK了]，耐心等待安装即可。完毕后发现空目录多出很多文件，如下图：这里的node_modules是项目依赖，在初始化的时候已经下载下来了，不用再 hexoi 了(有的教程写的hexo i 就是安装依赖的作用)。 测试本地运行 上述环境完成后，我们就可以在本地预览blog了。很简单，两行命令。 键入命令 hexo generate 生成静态文件，可以简写为 hexo g 键入命令 hexo server 在本地运行， 可以简写为 hexo s 打开浏览器，地址栏键入 http://localhost:4000 即可进行预览，效果如下 总结 经过以上操作，我们已经在本地搭建好了blog项目，并且在浏览器上预览成功，下一篇将接着写怎么把本地blog部署到github上，再换一个好看主题。==更多精彩微信关注：随心下（Suixinxia007）==]]></content>
  </entry>
  <entry>
    <title><![CDATA[GitHub+Hexo搭建自己的Blog之(2)-项目部署]]></title>
    <url>%2F2019%2F02%2F01%2FGitHub%2BHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Blog%E4%B9%8B(2)-%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[前言 上一篇文章我们已经把本地的hexo环境搭建好了，并且在本地成功预览，但是本地预览也意味着自己的博文只能自己看的到，其他人根本看不到，这篇文章将接上文说一说如何把本地Blog部署到GitHub上，好让小伙伴可以来访问我们的博客。 步骤总览 在github上创建一个仓库 注意此仓库的名称格式是： 你的github用户名.github.io (其中用户名不区分大小写)如下图 修改hexo文件配置 要想部署到github，需要对本地myblog文件夹下的 _config.yml 文件进行配置 用你的编译器打开该文件，拉到最后，找到 deploy 选项，作如下配置: 1 deploy: 2 type: git 3 repo: git@github.com:yg201506/yg201506.github.io.git 4 baranch: master 其中， repo 填写你刚刚github创建的仓库的地址，点进你的仓库，如图 找到地址复制粘贴过来即可注意；每个冒号后面都要有一个空格，如图 部署 部署之前，需要安装 git部署插件 打开myblog文件夹，调出Powershell终端，键入 cnpm i hexo-deployer-git-S 安装插件 安装完毕后，键入命令 hexo g 生成静态文件 键入命令 hexo d 完成部署 再进入到github，进入io仓库，点击setting 进入设置，往下拉至 GitHub，可看到页面创建成功（此处绑定自己的域名） 这时候只需要地址栏中输入 yg201506.github.io (输入自己的github名称.github.io)即可访问刚刚部署成功的Blog啦。 总结 现在我们就成功的把Blog从本地部署到了github服务器上了，可以把自己的地址发给小伙伴访问啦，动手试试吧。 ==更多精彩微信关注：随心下（Suixinxia007）==]]></content>
  </entry>
  <entry>
    <title><![CDATA[GitHub+Hexo搭建自己的Blog之(3)-主题配置(Next)]]></title>
    <url>%2F2019%2F01%2F30%2FGitHub%2BHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Blog%E4%B9%8B(3)-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE-Next%2F</url>
    <content type="text"><![CDATA[Blog的环境全部搭建完毕后，由于没有内容，而且hexo默认的主题是不是感觉挺丑的，其实hexo给我们提供了很多主题模板，总有一款是你喜欢的，本篇文章将说一说如何配置主题，怎么创建博文，写好后又如何发布，一起来看吧! 点我进入hexo官网挑选模板 文章总览Hexo主目录作用 如图是我们hexo文件的主目录，由上往下文件的作用 node_modules：是我们这个hexo整个项目的环境依赖，自动生成的，不用理会。 public：存放的是整个项目的页面，样式，及逻辑代码。 scaffolds：scaffolds是脚手架的意思，当你新建一篇文章(hexo new page ‘title’)的时候，hexo是根据这个目录下的文件进行构建的。不用关心。 source：这个目录很重要，新建的文章都是在保存在这个目录下的_posts 。_posts 目录下是一个个 markdown 文件。初始里面有一个 hello-world.md 的文件，文章就在这个文件中编辑。_posts 目录下的md文件，会被编译成html文件，放到 public 文件夹下。 themes：是网站的主题目录，Hexo有很好的主题扩展能力，开源主题也很丰富，该目录下每一个子目录就是一个主题。 _config.yml：全局配置文件，我们Blog站点的很多信息都是在这个文件中配置的，比如网站的名字，副标题，网站描述信息，作者等等。 package.json：这个文件里我们可以看到hexo所依赖的插件。接下来详细说一说 _config.yml 文件的配置“”Configuration12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 黑科大侠 #网站标题subtitle: #网站副标题description: #网站描述author: yg201506 #作者language: #语言timezone: #网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://xxxxxx #你的站点Urlroot: / #站点的根目录permalink: :year/:month/:day/:title/ #文章的 永久链接 格式 permalink_defaults: #永久链接中各部分的默认值# Directory source_dir: source #资源文件夹，这个文件夹用来存放内容public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags # 标签文件夹 archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #Include code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染 # Writingnew_post_name: :title.md # 新文章的文件名称default_layout: post #预设布局titlecase: false # 把标题转换为 title caseexternal_link: true # 在新标签中打开链接filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false #是否显示草稿post_asset_folder: false #是否启动 Asset 文件夹relative_link: false #把链接改为与根目录的相对位址 future: true #显示未来的文章highlight: #内容中代码块的设置 enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map: #分类别名tag_map: #标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD #日期格式time_format: HH:mm:ss #时间格式 # Pagination## Set per_page to 0 to disable paginationper_page: 10 #分页数量pagination_dir: page # Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape #主题名称 # Deployment## Docs: https://hexo.io/docs/deployment.html# 部署部分的设置deploy: type: git repo: yg201506@github.com:yg201506/yg201506.github.io.git #这里我们之前部署到github时配置过的 baranch: master 更换Next主题本文介绍Next主题的配置用法，其他的主题用法大体步骤是类似的。更多详情：点我了解更多 主题下载：进入到hexo文件目录下，打开powershell终端，键入命令：git clone https://github.com/theme-next/hexo-theme-next themes / next 下载完毕，我们打开themes文件夹，会发现多出一个next的文件夹。 应用主题：打开根hexo目录下的 _config.yml 文件，修改themes的值为 next 如图 预览：进入终端在根目录 hexo 下依次键入如下命令：o hexo clean 先清理一下hexo的缓存o hexo s 本地启动服务o 打开浏览器：在地址栏键入 http://localhost:4000 预览，如图Next配置next主题应用成功之后，也是需要友好的配置一下，打开themes文件夹下的next文件会看到也有一个 _config.yml 的文件，有了之前的经验，我们知道这个就是next主题的全局配置文件了_config.yml配置截取了一部分，这里基本上是需要配置的，其他的基本是默认，更多的配置，可看这篇教程点我查看更多炫酷设置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262favicon: # 这里配置站点的站标 # small: /images/favicon-16x16-next.png medium: /images/favicon-16x16-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml# Set default keywords (Use a comma to separate)keywords: # 这里放置站点的关键字 &quot;前端, HTML, CSS, javascript, Vue.js, Node.js, MySQL, 微信小程序&quot;# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss:footer: # 网站的页脚设置 # Specify the date when the site was setup. # If not defined, current year will be used. since: # 网站的开始运行时间 比如设置2017 则网站底部显示 2017-2018 # Icon between year and copyright info. icon: user # If not defined, will be used `author` from Hexo main config. # copyright: # ------------------------------------------------------------- # Hexo link (Powered by Hexo). # powered: true # theme: # Theme &amp; scheme info link (Theme - NexT.scheme). # enable: false # Version info of NexT after scheme info (vX.X.X). # version false # ------------------------------------------------------------- # Any custom text can be defined here. #custom_text: Hosted by &lt;a target=&quot;_blank&quot; href=&quot;https://pages.github.com&quot;&gt;GitHub Pages&lt;/a&gt;# ---------------------------------------------------------------# SEO Settings# ---------------------------------------------------------------# Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.# See: https://support.google.com/webmasters/answer/139066# Tips: Before you open this tag, remember set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )canonical: true# Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.seo: false# If true, will add site-subtitle to index page, added in main hexo config.# subtitle: Subtitleindex_with_subtitle: false# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).# Usage: `Key: /link/ || icon`# Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive.# Value before `||` delimeter is the target link.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.menu: # 菜单路径 注意：下边的 || 不能去掉 后边表示的是 对应的图标 home: / || home # 表示主页 tags: /tags/ || tags # 表示标签 categories: /categories/ || th # 表示分类 archives: /archives/ || archive #表示归档 about: /about/ || user #表示关于我 life: /life/ || heart #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat # 公益活动# Enable/Disable menu icons.menu_icons: # 这里是图标设置 和上边的 || 后面的一致 enable: true home: home tags: tags categories: th archives: archive about: user life: heart# ---------------------------------------------------------------# Scheme Settings 这里是next主题的样式排版设置# ---------------------------------------------------------------# Schemes next给提供了如下四个页面布局方式 只能选择其中的一个使用，具体样式，可自己动手试试，我这里选择的是Mist# scheme: Musescheme: Mist# scheme: Pisces# scheme: Gemini# ---------------------------------------------------------------# Sidebar Settings 社交设置# ---------------------------------------------------------------# Social Links. # Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.social: # 自己的社交链接 比如这里我设置了 Github 和 邮箱，下面还可以设置 微博之类的 自己动手设置试试 GitHub: https://github.com/RoseSnow || github E-Mail: number_nine@126.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skypesocial_icons: # 这里是设置上面社交链接 的对应图标的 对应的设为 true 即可 enable: true Github: github icons_only: false transition: false# Blog rolls # 这里是设置一些相关链接 我这里设置了一些推荐阅读的网站，可自行设置links_icon: linklinks_title: 推荐阅读# links_layout: blocklinks_layout: inlinelinks: w3school: http://www.w3school.com.cn/ 菜鸟教程: http://www.runoob.com/ 廖雪峰官网: https://www.liaoxuefeng.com/# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /images/avatar.jpg # 这里设置自己的头像# Table Of Contents in the Sidebar # 文章自动显示的目录toc: enable: true # Automatically add list number to toc. 文章是否显示序号，显示则设置为true number: false # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: # Sidebar Position, available value: left | right (only for Pisces | Gemini). position: left #position: right # Sidebar Display, available value (only for Muse | Mist): # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle. display: post #display: always #display: hide #display: remove # Sidebar offset from top menubar in pixels (only for Pisces | Gemini). offset: 12 # Back to top in sidebar (only for Pisces | Gemini). b2t: false # Scroll percent label in b2t button. scrollpercent: false # Enable sidebar on narrow view (only for Muse | Mist). onmobile: false# ---------------------------------------------------------------# Post Settings# ---------------------------------------------------------------# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically saving scroll position on each post/page in cookies.save_scroll: false# Automatically excerpt description in homepage as preamble text.excerpt_description: true# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true length: 120# Post meta display settingspost_meta: item_text: true created_at: true updated_at: false categories: true# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true totalcount: true separated_meta: true# Wechat Subscriber 设置微信添加方式wechat_subscriber: enabled: true qcode: /images/mywechat.jpg description: 扫一扫添加微信好友# Reward # 设置打赏方式reward_comment: 如果觉得文章不错，请我吃根辣条吧~~wechatpay: /images/wxpay.pngalipay: /images/alipay.png# bitcoin: /images/bitcoin.png# Declare license on postspost_copyright: enable: false license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Reduce padding / margin indents on devices with narrow width.mobile_layout_economy: false# Android Chrome header panel color ($black-deep).android_chrome_color: &quot;#222&quot;# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images&apos;s urlcustom_logo: enabled: false image:# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night eighties 创建其他页面首页和归档是默认存在的，不需要我们自己创建，但是其他的几个诸如分类，标签，关于是要我们自己创建的如图 创建分类：终端hexo根目录下键入命令 hexo new page categories 之后我们进入 hexo/source目录下发现多出一个名为 categories 的文件夹, 打开categories下的index.md,可以看到是这样的 如图 标签页面和关于页面的创建方法都是和分类的一样，重复上一步即可。创建第一篇博文我们一直在配置环境，还没有真正动手写博客，下面我们来创建第一篇博客。 仍然是用new命令创建：在终端myblog下键入命令 hexo page “文章标题” 打开source文件夹下的_posts文件，就可以看到我们刚刚创建的 “文章名称”.md的 文件，用编辑器打开，就可以编写内容了，其中文章可以设置分类和标签，如图提交到远程服务下面把我们的博客提交一下，上一篇我们已经把Blog部署到了GitHub上，所以可以提交到github服务器上。 hexo clean 注意：每次提交前建议都执行一下该命令，清除一下 hexo g 生成本地静态文件 hexo s 启动本地服务，在本地预览 hexo d 本地预览无误后，提交到远仓下面我们再打开网址 https://yg201506.github.io (此处更换你自己的io地址)就可以访问我们刚刚创建的博文了总结经过这三篇文章，我们已经从0到1搭建起了自己的Blog，想让Blog更个性化，可以参考点我查看更多炫酷设置，接下来还有一篇会写一下怎么绑定个人的域名。]]></content>
      <categories>
        <category>网站搭建</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[别盲考，全国计算机等级考试指南了解一下]]></title>
    <url>%2F2019%2F01%2F30%2F%E5%88%AB%E7%9B%B2%E8%80%83%EF%BC%8C%E5%85%A8%E5%9B%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AD%89%E7%BA%A7%E8%80%83%E8%AF%95%E6%8C%87%E5%8D%97%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[有好多同学报考了全国计算机等级考试，但对最新的考试内容和考试规则还不太了解，今天就为大家整理了一份全国计算机等级考试考试指南，先仔细了解一下，希望对大家有所帮助！ 1、什么是全国计算机等级考试？全国计算机等级考试（National Computer Rank Examination，简称NCRE），是经原国家教育委员会（现教育部）批准，由教育部考试中心主办，面向社会，用于考查应试人员计算机应用知识与技能的全国性计算机水平考试体系。## 2、NCRE的证书如何构成？## 3、2018年版NCRE大纲中，各级别科目设置及证书获证条件如何？ 4、有没有统一的考试大纲和辅导教材，如何购买？教育部考试中心对所有开考科目都制订了统一的考试大纲，具体规定了各等级的考试要求和内容范围，是命题的依据。同时，为了帮助考生学习和应考，教育部考试中心还组织专家编写了全国计算机等级考试系列教程（含考试大纲），由高等教育出版社独家出版。考生可到各地书店购买。 5、NCRE采取什么考试形式？考试时长是怎么规定的？考试形式：统一命题，统一考试。全部实行上机考试。 考试时长：一级、四级为90分钟；二级、三级为120分钟。 6、如何计算成绩？是否有合格证书？NCRE考试实行百分制计分，但以等第形式通知考生成绩。成绩等第分为“优秀”、“良好”、“及格”、“不及格”四等。100-90分为“优秀”，89-80分为“良好”，79-60分为“及格”，59-0分为“不及格”。 考试成绩优秀者，在证书上注明“优秀”字样；考试成绩良好者，在证书上注明“良好”字样；考试成绩及格者，在证书上注明“合格”字样。 7、NCRE每年考几次？什么时候考试？什么时候报名？NCRE考试时间为每年3月、9月、12月，其中12月份的考试由省级承办机构根据情况自行决定是否开考； 每次考试具体报名时间由各省级承办机构规定，可登录各省级承办机构网站查询。 8、考生一次可以报考几个科目？同次考试，考生最多可报三个科目，且不允许重复报考同一个科目。严禁考生同时在多个省级承办机构报名。 四级的成绩可保留一次。如：考生同时报考了三级网络技术、四级网络工程师两个科目，结果通过了四级网络工程师考试，但没有通过三级网络技术考试，将不颁发任何证书，四级网络工程师考试成绩保留一次。下一次考试，考生报考三级网络技术并通过，将一次获得三级和四级两个证书；若没有通过，将不能获得任何证书，同时，四级网络工程师考试成绩自动失效。 9、成绩与证书何时下发？教育部考试中心将在考后30个工作日内向省级承办机构下发考试成绩数据；省级承办机构应在收到成绩数据后5个工作日内完成对考生成绩下发工作。成绩公布后，考生可登录中国教育考试网（www.neea.edu.cn）进行成绩查询。 教育部考试中心将在考后45个工作日内将合格证书下发给省级承办机构，然后由各省级承办机构逐级转发给考生。考生在考后可登录中国教育考试网申请NCRE证书直邮服务，有关要求和申请流程详见网站。 10、如果对成绩有疑义怎么办？考生对成绩如有疑问，应在省级承办机构下发成绩后5个工作日内，向所在考点提出书面申请，由考点逐级上报。 内容来源：教育部考试中心]]></content>
  </entry>
</search>
